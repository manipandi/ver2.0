 var jsVersion = '0.1.0 - May,29 2017 11:17';                   var nwUserAgent = navigator.userAgent + " Tc-webkit";
Array.prototype.filterObjects = function(key, value) {
    return this.filter(function(x) {
        return x[key] === value;
    });
};

Array.prototype.removeItem = function(key, value) {
    if (value == undefined) return;
    for (var i in this) {
        if (this[i][key] == value) {
            this.splice(i, 1);
        }
    }
};

Object.merge = function(o1, o2) {
    if (typeof o1 == "object" && typeof o2 == "object") {
        for (var i in o2) {
            o1[i] = o2[i];
        }
        return o1;
    }
    throw new Error("Arguments are not Objects");
};

(function(R, undefined) {
    $("#v2_Phone_Icon").hide();
    var path = FULLClient.require("path");
    function getConfig() {
        var config;
        try {
            config = require(path.join(process.resourcesPath, "app", "config", "config.json"));
        } catch (e) {
            config = require(path.join(process.cwd(), "config", "config.json"));
        }
        return config;
    }
    function getFilePath() {
        if (getConfig() && getConfig().mode == "code") {
            return process.cwd();
        } else {
            return path.join(path.join(process.resourcesPath, "app"));
        }
    }
    function getManifest() {
        var manifest;
        try {
            manifest = require(path.join(process.resourcesPath, "app", "package.json"));
        } catch (e) {
            manifest = require(path.join(process.cwd(), "package.json"));
        }
        return manifest;
    }
    FULLClient.name = "FULLClientGlobal";
    FULLClient.canQuit = false;
    FULLClient.log = function() {
        var tmp = [];
        for (var i = arguments.length - 1; i >= 0; i--) {
            tmp[i] = arguments[i];
        }
        tmp.splice(0, 0, "[" + this.name + "] : ");
        console.debug.apply(console, tmp);
    };
    FULLClient.quit = function() {};
    FULLClient.isElectron = function() {
        return process.versions["electron"];
    };
    FULLClient.config = getConfig();
    FULLClient.manifest = getManifest();
    FULLClient.getManifest = getManifest;
    FULLClient.getMode = function() {
        return this.config.mode;
    };
    FULLClient.isModeValid = function(mode) {
        if ([ "1.x", "test-1.x", "lily" ].indexOf(mode) !== -1) {
            return true;
        }
    };
    FULLClient.setMode = function(mode) {
        if (this.isModeValid(mode)) {
            this.config.mode = mode;
            util.app.update();
            return true;
        }
        throw new Error("Mode is not compatible : " + mode);
    };
    FULLClient.getAppName = function() {
        if (/^darwin/.test(process.platform)) return path.basename(process.execPath).substring(0, path.basename(process.execPath).lastIndexOf(" ")); else return path.basename(process.execPath).substring(0, process.execPath.lastIndexOf("\\"));
    };
    FULLClient.getConfig = function() {
        return this.config[this.getMode()];
    };
    FULLClient.getFilePath = getFilePath;
    FULLClient.getAppPath = function() {
        return FULLClient.getFilePath().replace(/([\/]Contents.*)/g, "");
    };
    FULLClient.set = function(key, value) {
        this[key] = value;
    };
    FULLClient.getAsarPath = function() {
        var arr = FULLClient.getManifest().main.match(/(.*asar)/g);
        return arr && arr.length ? "../" + arr[0] : "../asar/full.asar";
    };
})(this);

var shell = FULLClient.require("electron").shell;

var path = FULLClient.require("path");

var clipboard = require("electron").clipboard;

var remote = require("electron").remote;

var util = {
    name: "utilities",
    log: function() {
        console.debug.apply(console, arguments);
    }
};

util.hasSpecialCharacters = function(data) {
    var regex = /([^a-zA-Z0-9])/;
    if (typeof data == "string" && data && !regex.test(data)) {
        return false;
    }
    return true;
};

util.getSharedObject = function() {
    return remote.getGlobal("sharedObject");
};

util.isHttps = function(url) {
    return url && url.includes("https://");
};

util.document = {
    shadowRootFocus: function(webView) {
        if (webView && webView.shadowRoot) {
            webView.shadowRoot.querySelector("object").focus();
            this.releaseFocus();
            return true;
        }
    },
    releaseFocus: function() {
        const element = document.createElement("span");
        document.body.appendChild(element);
        const range = document.createRange();
        range.setStart(element, 0);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        selection.removeAllRanges();
        document.body.removeChild(element);
    },
    claimFocus: function() {
        const activeElement = document.activeElement;
        const selection = window.getSelection();
        var selectionStart, selectionEnd, range;
        if (activeElement) {
            selectionStart = activeElement.selectionStart;
            selectionEnd = activeElement.selectionEnd;
        }
        if (selection.rangeCount) range = selection.getRangeAt(0);
        const restoreOriginalSelection = function() {
            if (selectionStart >= 0 && selectionEnd >= 0) {
                activeElement.selectionStart = selectionStart;
                activeElement.selectionEnd = selectionEnd;
            } else if (range) {
                selection.addRange(range);
            }
        };
        requestAnimationFrame(restoreOriginalSelection);
    }
};

util.showBadgeLabel = function(count) {
    if (!count) count = "";
    var text = count.toString().trim(), cDom = document.querySelector("canvas");
    var canvas = cDom ? cDom : document.createElement("canvas");
    canvas.height = 140;
    canvas.width = 140;
    var ctx = canvas.getContext("2d");
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.ellipse(70, 70, 70, 70, 0, 0, 2 * Math.PI);
    ctx.fill();
    ctx.textAlign = "center";
    ctx.fillStyle = "white";
    if (text.length > 2) {
        ctx.font = "75px sans-serif";
        ctx.fillText("" + text, 70, 98);
    } else if (text.length > 1) {
        ctx.font = "100px sans-serif";
        ctx.fillText("" + text, 70, 105);
    } else {
        ctx.font = "125px sans-serif";
        ctx.fillText("" + text, 70, 112);
    }
    if (count && parseInt(count)) {
        FULLClient.ipc.send({
            eType: "setOverlayIcon",
            dataURL: canvas.toDataURL()
        });
        return text;
    } else {
        FULLClient.ipc.send({
            eType: "setOverlayIcon",
            count: null
        });
    }
    return false;
};

util.escapeSpaces = function(str) {
    if (str && typeof str == "string") {
        return str.replace(/[ ]/g, "\\ ");
    }
};

util.getTempDirectory = function() {
    return process.env.TMPDIR || process.env.TEMP || process.env.TMP;
};

util.print = {
    appInfo: function() {
        var tmp = {
            mode: FULLClient.getMode(),
            packageJson: FULLClient.getManifest(),
            config: FULLClient.getConfig(),
            asarPath: FULLClient.getAsarPath()
        };
        return tmp;
    }
};

util.scripts = {
    get: function() {
        return document.scripts[document.scripts.length - 1];
    }
};

util.debounce = function(func, wait, immediate) {
    var timeout;
    return function() {
        var context = this, args = arguments;
        var later = function() {
            timeout = null;
            if (!immediate) func.apply(context, args);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
    };
};

util.doNotBubble = function(e) {
    if (e) {
        e.cancelBubble = true;
    }
};

util.mocha = {
    sb: function() {
        FULLClient.ipc.send({
            eType: "open",
            title: "sbMocha"
        });
    },
    v2: function() {
        FULLClient.ipc.send({
            eType: "open",
            title: "v2Mocha"
        });
    }
};

util.analytics = {
    push: function(accountNumber, eventAction, connId, metaInfo) {
        util.publish("/analytics/push", accountNumber, eventAction, connId, metaInfo);
    }
};

util.user = {
    isUserInfoAvailable: function() {
        return userDAO.getUser() ? userDAO.getUser() : false;
    },
    getEmail: function() {
        var _user = this.isUserInfoAvailable();
        if (_user) {
            return _user.email;
        }
    }
};

util.getRemote = function() {
    return FULLClient.require("electron").remote;
};

util.preventEvent = function(e) {
    if (e) {
        e.cancelBubble ? e.cancelBubble = true : false;
        e.preventDefault ? e.preventDefault() : false;
    }
};

util.getDemoLines = function() {
    return [ "8007066511", "8004616705", "8004617310", "8004619489", "8004619578", "8008050816", "8008352647", "8004611592", "8004614207", "8004615165", "8004617420", "8007047593", "8007066572", "8004618540", "8004612449", "8004619537", "8008087316", "8004615398", "8004617493", "8007047614", "8004611676", "8006800906", "8004612458", "8004614214", "8007066573", "8004618597", "8004612596", "8007047591", "8004618658", "8008087751", "8007047635", "8004611683", "8005456981", "8004614237", "8004618497", "8004615406", "8007066604", "8004618659", "8004614259", "8007047636", "8007047643", "8004612413", "8004614359", "8005457026", "8004614250", "8004618512", "8004616486", "8008088543", "8007066609", "8004612435", "8007047641", "8004614784", "8006800797", "8004618523", "8004615502", "8004614354", "8004616508", "8006352757", "8008088612", "8007066615", "8004614425", "8004616495", "8004618524", "8004616539", "8004610376", "8006352780", "8004612497", "8004618678", "8006800904", "8007047684", "8004614706", "8007066617", "8004612597", "8004618552", "8006800910", "8004610485", "8007066618", "8007095720", "8004617250", "8008038489", "8008038490", "8008038514", "8008038516", "8008038529", "8008038532", "8008038533", "8008352608", "8008352718", "8008352909", "8008353022", "8008353430", "8008391943", "8008392012", "8008392169", "8008392197", "8008392252", "8006352720", "8004612183", "8004612417", "8773257467", "8773257468", "8773257480", "8773257488", "8773257495", "8773257496", "8773257497", "8773257498", "8773257499", "8773257763", "8773257785", "8773258200", "8773258711", "8773258981", "8773259051", "8773259052", "8773259055", "8773259056", "8773259060", "8773259063", "8773259064", "8773259065", "8773259070", "8773259073", "8773259742", "8773261118", "8773261123", "8773261142", "8773261919", "8773265164", "8773265367", "8773265371", "8773265607", "8773265961", "8773267997", "8773267998", "8773268102", "8773269238", "8773269321", "8773271035", "8773271271", "8773271601", "8773271602", "8773271606", "8773271607", "8773271750", "8773271981", "8773272107", "8773272242", "8773272246", "8773272285", "8773272483", "8773273082", "8773273292", "8773273937", "8773275427", "8773275687", "8773276074", "8773276078", "8773276079", "8773276080", "8773276081", "8773276085", "8773276270", "8773276637", "8773276966", "8773277162", "8773278001", "8773278408", "8773278409", "8773278693", "8773278842", "8773279172", "8773279682", "8773280314", "8773281194", "8773281286", "8773281357", "8773281416", "8773281886", "8773282321", "8773282399", "8773282475", "8773282826", "8773283207", "8773283285", "8773285258", "8773286354", "8773287453", "8773288576", "8773289801", "8773290433", "8773290598", "8773290615", "8773291275", "8773291279", "8773299571", "8773299576", "8773299969", "8773299970" ];
};

util.getParameterByName = function(name, url) {
    if (name && url) {
        name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
        var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"), results = regex.exec(url);
        return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
    }
};

util.getParameters = function(url) {
    if (!url) return {};
    var keyValue = {};
    if (url.indexOf("?") !== -1) {
        var lUrl = url.split("?");
        lUrl = lUrl[1].split("&");
        for (var i = lUrl.length - 1; i >= 0; i--) {
            var key, value;
            key = lUrl[i].split("=")[0];
            value = lUrl[i].split("=")[1];
            keyValue[key] = value;
            if (/connid/.test(key)) keyValue["connId"] = value;
        }
    }
    return keyValue;
};

util.isFetch = function(params) {
    if (params && (params.fetch || params.isAgentResearch)) {
        return true;
    }
};

util.isEmail = function(email) {
    var re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    return re.test(email);
};

util.loadWebSiteInBrowser = function(url) {
    if (util.isUrl(url)) {
        shell.openExternal(url);
    }
};

util.loadWebSiteInNewWindow = function(url) {
    if (util.isUrl(url)) {
        FULLClient.emitter.sendToMain({
            eType: "loadWebsiteInNewWindow",
            url: url
        });
    }
};

util.loadURL = function(url, options, cb) {
    var newurl;
    if (url) {
        url += url.indexOf("?") != -1 ? "" : "?";
        if (url.indexOf("http") == -1 && (newurl = "http://" + url) && this.isUrl(newurl)) {
            url = newurl;
        }
    }
    if (this.isUrl(url)) {
        if (util.window.getName() == namespace.CONTAINER_SB) {
            this.publish("/tab/controller/create", url, options, cb);
        } else {
            var accLoad = new SBcommunication("accountOpt");
            accLoad[accLoad.opt].opt = "load";
            accLoad[accLoad.opt].url = url;
            FULLClient.ipc.sendToSB(accLoad);
        }
        return;
    }
    throw new Error("Invalid URL : " + url);
};

util.publish = function(scheme, context) {
    amplify.publish.apply(amplify, arguments);
};

util.subscribe = function(scheme, context) {
    amplify.subscribe.apply(amplify, arguments);
};

util.unsubscribe = function(scheme, context) {
    amplify.unsubscribe.apply(amplify, arguments);
};

util.debug = {
    _activateDebug: function() {
        util.log("Debugging : ", util);
    },
    _deActivateDebug: function() {},
    on: function() {
        this._activateDebug();
        util.publish("/debug/switch/global/on");
    },
    off: function() {
        util.publish("/debug/switch/global/off");
    }
};

util.getBrowserWindow = function() {
    return this.getRemote().BrowserWindow;
};

util.getAllWindows = function() {
    return this.getBrowserWindow().getAllWindows();
};

util.notification = {
    truncate: function(str, charRestrictionCount) {
        if (str && charRestrictionCount && str.length > charRestrictionCount) {
            return str.substr(0, charRestrictionCount);
        }
        return str;
    },
    isValid: function(nObj) {
        return nObj && nObj.title && nObj.body;
    },
    getTitle: function(nObj) {
        return this.truncate(nObj.title, 45);
    },
    getBody: function(nObj) {
        return this.truncate(nObj.body, 150);
    },
    create: function(nObj) {
        if (this.isValid(nObj)) {
            var n = new ClientListener("notify");
            n[n.opt].title = this.getTitle(nObj);
            n[n.opt].body = this.getBody(nObj);
            util.publish("/notification/create/show", n);
        }
    },
    prevent: function() {
        if (/^win/.test(process.platform)) {
            console.warn("preventing native notifications");
            util.getCurrentWindow().webContents.session.setPermissionRequestHandler(function(webContents, permission, callback) {
                if (permission === "notifications") {
                    return callback(false);
                }
                callback(true);
            });
            return true;
        }
    }
};

util.caching = {
    windows: {
        v2: null,
        sb: null,
        chat: null,
        timer: null,
        reset: function() {
            this.v2 = this.sb = this.chat = this.timer = null;
        },
        getByTitle: function() {
            return this.getTarget(util.window.getName());
        },
        getV2: function() {
            return this.v2 ? this.v2 : this.getTarget(namespace.CONTAINER_V2);
        },
        getSB: function() {
            return this.sb ? this.sb : this.getTarget(namespace.CONTAINER_SB);
        },
        getChat: function() {
            return this.chat ? this.chat : this.getTarget(namespace.CONTAINER_CHAT);
        },
        getTimer: function() {
            return this.timer ? this.timer : this.getTarget(namespace.CONTAINER_TIMER);
        },
        getTarget: function(title) {
            var targetArray = util.getAllWindows();
            for (var i = targetArray.length - 1; i >= 0; i--) {
                if (targetArray[i].getURL().indexOf(title + ".html") !== -1) {
                    switch (title) {
                      case namespace.CONTAINER_V2:
                        {
                            this.v2 = targetArray[i];
                            return this.v2;
                        }

                      case namespace.CONTAINER_CHAT:
                        {
                            this.chat = targetArray[i];
                            return this.chat;
                        }

                      case namespace.CONTAINER_TIMER:
                        {
                            this.timer = targetArray[i];
                            return this.timer;
                        }

                      default:
                        {
                            this.sb = targetArray[i];
                            return this.sb;
                        }
                    }
                }
            }
        }
    }
};

util.getCurrentWindow = function() {
    return this.caching.windows.getByTitle() || this.getRemote().getCurrentWindow();
};

util.clear = function() {
    if (!util.clear.isCleared) {
        util.clear.isCleared = true;
        this.httpCache.clear();
        this.cookies.clear();
        this.storage.clear();
        userDAO.clear();
    }
};

util.persistentStorage = {
    clear: function(cb) {
        var storage = [ "appcache", "cookies", "indexdb", "local storage" ];
        var quota = [ "temporary", "persistent", "syncable" ];
        util.getCurrentWindow().webContents.session.clearStorageData({
            storage: storage,
            quotas: quota
        }, cb || function clearStorage() {
            console.warn("storage clear for following ", storage, quota);
        });
    }
};

util.flush = function() {
    util.getCurrentWindow().webContents.session.flushStorageData();
};

util.webview = {
    post: function(webview, msg, channel) {
        if (webview && msg && typeof msg == "object") {
            webview.send(channel || "webapp-msg", msg);
        }
    }
};

util.getInitObj = function(tabId) {
    return {
        name: "init",
        opt: "userinfo",
        init: {
            tabIndex: tabId,
            contactInfo: JSON.stringify(userDAO.getUserDcmResponse())
        },
        isElectron: true,
        source: "AnyWhereWorks"
    };
};

util.storage = {
    isAvailable: function() {
        return typeof Locstor == "function" ? true : false;
    },
    set: function(k, v) {
        if (k && v && this.isAvailable()) {
            Locstor.set(k, v);
        }
    },
    get: function(k) {
        if (k && this.isAvailable()) {
            return Locstor.get(k);
        }
    },
    clear: function() {
        if (this.isAvailable()) {
            util.log("LOCALSTORAGE is getting cleared !!");
            Locstor.clear();
        }
    }
};

util.window = {
    getName: function() {
        var scripts = util.scripts.get();
        var title;
        switch (path.basename(scripts.src)) {
          case "chatContainer.js":
            {
                title = namespace.CONTAINER_CHAT;
                break;
            }

          case "webContainer.js":
            {
                title = namespace.CONTAINER_SB;
                break;
            }

          case "v2Container.js":
            {
                title = namespace.CONTAINER_V2;
                break;
            }

          default:
            {
                break;
            }
        }
        return title;
    }
};

util.httpCache = {
    remove: function() {
        var remote = util.getRemote();
        var win = remote.getCurrentWindow ? remote.getCurrentWindow() : false;
        if (win) {
            win.webContents.session.clearCache(function() {
                util.log("CacheCleared ", arguments);
            });
        }
    },
    clear: function() {
        util.log("httpCache is getting cleared !!");
        this.remove();
    }
};

util.copy = function(text) {
    clipboard.writeText(text);
};

util.clipboard = {
    read: function() {
        var tc = new Thinclient("readFromClipboard"), option = tc[tc.opt], image = this.readImage();
        if (image.isEmpty()) {
            option.type = "text";
            option.text = this.readText();
        } else {
            option.type = "Image";
            option.image = image;
        }
        return tc;
    },
    readImage: function() {
        var data = clipboard.readImage();
        var imgUrl = !data.isEmpty() ? data.toDataUrl() : "";
        return {
            dataUri: imgUrl,
            size: data.getSize(),
            isEmpty: imgUrl ? false : true
        };
    },
    writeImage: function(path) {
        return clipboard.writeImage(path);
    },
    readText: function() {
        return clipboard.readText();
    },
    writeText: function(text) {
        return text ? clipboard.writeText(text) : false;
    }
};

util.cookies = {
    clear: function() {
        util.log("COOKIES is getting cleared !!");
        this.removeAllCookies();
    },
    _delete: function(cookies, win, dfd) {
        if (typeof cookies == "object" && win) {
            var args = [], cb = function(error) {
                if (error) dfd ? dfd.reject("Error") : false; else dfd.resolve("success");
            }, URL = "http" + (cookies.secure ? "s" : "") + "://" + cookies.domain + cookies.path;
            console.log("url : " + URL + ", cookies name : " + cookies.name);
            args.push(URL);
            args.push(cookies.name);
            args.push(cb);
            win.webContents.session.cookies.remove.apply(null, args);
        }
    },
    get: function(domainName, cb) {
        var remote = util.getRemote(), cookieDomainObj = {}, win = remote.getCurrentWindow ? remote.getCurrentWindow() : false;
        if (domainName) cookieDomainObj["domain"] = domainName;
        win.webContents.session.cookies.get(cookieDomainObj, cb);
    },
    remove: function(domainName) {
        if (domainName) return this.removeAllCookies(domainName);
        throw Error("Domain name is not Valid " + domainName);
    },
    getDFDs: function(length) {
        var tmp = [];
        for (var i = 0; i < length; i++) {
            tmp.push($.Deferred());
        }
        return tmp;
    },
    cookieDeletion: function(arr) {
        $.when.apply($, arr).done(function() {
            console.log("Cleared Cookies successfully ");
            util.publish("/app/cookies/cleared");
        }).fail(function() {
            console.log("failed");
        });
    },
    removeAllCookies: function(domainName) {
        var removeDFD = [], self = this, remote = util.getRemote(), cookieDomainObj = {}, keys, win = remote.getCurrentWindow ? remote.getCurrentWindow() : false;
        if (domainName) cookieDomainObj["domain"] = domainName;
        if (win) {
            win.webContents.session.cookies.get(cookieDomainObj, function(error, cookies) {
                keys = Object.keys(cookies);
                removeDFD = util.cookies.getDFDs(keys.length);
                util.cookies.cookieDeletion(removeDFD);
                for (var i = 0; i < keys.length; i++) {
                    self._delete(cookies[keys[i]], win, removeDFD[i]);
                }
            });
        }
        return removeDFD;
    }
};

util.gmail = {
    session: function() {
        util.cookies.get("google.com", function(error, cookies) {
            if (error) {
                return;
            }
            var len = cookies.filter(function(cookie) {
                return /HID|SSID/.test(cookie.name);
            }).length;
            if (!len) {
                console.warn("Gmail session InActive.");
            } else {
                console.log("Gmail session active.");
            }
        });
    }
};

util.accessMods = {
    mask: {
        enumerable: false,
        writable: true,
        configurable: false
    },
    protected: {
        enumerable: true,
        writable: false,
        configurable: false
    },
    private: {
        enumerable: false,
        writable: false,
        configurable: false
    }
};

util.UI = {
    v2: $("#v2_Phone_Icon")
};

util.v2 = {
    getV2LastReceivedStatus: function() {
        var v2Obj = Locstor.get("v2");
        var status = null;
        if (v2Obj) {
            status = v2Obj.lastReceivedStatus;
        }
        return status;
    },
    isV2LoggedIn: function() {
        var v2 = util.storage.get("v2");
        if (v2 && v2.loggedIn) {
            return true;
        } else return false;
    },
    isV2Available: function() {
        return true;
    },
    getStatusList: function() {
        return [ "Email", "Offline", "ActiveResponse", "Active Response", "AfterCallWorks", "AfterCallWork", "Default", "Busy", "Available", "Repeat", "Chat", "Lunch", "Meeting", "Personal", "Project", "Training", "System", "Break", "Break2", "Break3", "PendingBusy", "CallingCustomer", "FailedConnectAgent", "Video Call", "Book Time", "Synclio Call", "Learning" ];
    },
    passOriginalEvent: function(originalObject) {
        if (!this.isV2Available()) return;
        if (typeof originalObject == "object" && originalObject.name == "v2Communication") {
            FULLClient.ipc.sendToV2(originalObject);
            return true;
        }
    },
    getV2Url: function() {
        return util.config.getV2url().split(/^(.*.com)/)[1] + "/AgentInfoAction/saveAgentInfo.do";
    },
    getAjaxData: function(StatusString, connIdString, isDummyBoolean) {
        return new UserClockStatus(StatusString, connIdString, isDummyBoolean);
    },
    getAjaxDetails: function(StatusString, connIdString, isDummyBoolean) {
        return {
            type: "POST",
            url: this.getV2Url(),
            data: this.getAjaxData(StatusString, connIdString || "N/A", !!isDummyBoolean)
        };
    },
    pushStatusToYoco: function(StatusString, connIdString, isDummyBoolean) {
        if (StatusString, connIdString) {
            return $.ajax(this.getAjaxDetails(StatusString, connIdString, isDummyBoolean));
        }
        throw new Error("Not Valid statusPush params ", {
            StatusString: StatusString,
            connIdString: connIdString,
            isDummyBoolean: isDummyBoolean
        });
    },
    statusPush: function(sObj) {
        if (typeof sObj == "object" && new RegExp(sObj.status, "g").test(this.getStatusList())) {
            if (!this.isV2LoggedIn()) {
                console.log("V2 is not LoggedIn ...,sending status to YOCO  :", sObj.status);
                this.pushStatusToYoco(sObj.status, "N/A", true);
            } else {
                var v2 = new V2Communication("statusPush");
                v2.statusPush = sObj.status;
                v2.isInterruptible = sObj.isInterruptible;
                v2.source = "FULLClient_utilities";
                v2.isForce = true;
                FULLClient.ipc.sendToV2(v2);
                return true;
            }
        }
    },
    dial: function(no) {
        if (!this.isV2Available()) return;
        if (util.isNumber(no)) {
            var dNo = new V2Communication("outbound");
            dNo[dNo.opt].phoneNumber = no;
            dNo.source = "FULLClient_utilities";
            dNo.isForce = true;
            FULLClient.ipc.sendToV2(dNo);
            return true;
        }
    }
};

util.isUrl = function(s) {
    var regexp = /(file|ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/;
    return s ? regexp.test(s) : false;
};

util.replaceAll = function(Source, stringToFind, stringToReplace) {
    var temp = Source;
    var index = temp.indexOf(stringToFind);
    while (index != -1) {
        temp = temp.replace(stringToFind, stringToReplace);
        index = temp.indexOf(stringToFind);
    }
    return temp;
};

util.isNumber = function(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
};

util.crashReporter = {
    port: null,
    _portDFD: null,
    getDFD: function() {
        if (!this._portDFD) {
            this._portDFD = $.Deferred();
        }
        return this._portDFD;
    },
    getPort: function() {
        if (!this._portDFD) {
            this.hook();
        }
        FULLClient.ipc.send({
            eType: "crashReporter",
            source: util.window.getName() == "AnyWhereWorks" ? "Chat" : util.window.getName(),
            opt: "port"
        });
    },
    setPort: function(port) {
        if (util.isNumber(port)) {
            this.port = port;
            this.getDFD().resolve(port);
        }
    },
    hook: function() {
        util.log("Hook Crash collector DFD ");
        this.getDFD().done(function(port) {
            util.log("Dynamic port been Captured in Crash Reporter", port);
            if (port) {
                util.log("Starting crash reporter in Browser Window " + document.title);
                var crashReporter = util.getRemote().crashReporter;
                crashReporter.start({
                    productName: "FULLClient-Electron",
                    companyName: "FULLCreative",
                    autoSubmit: true,
                    submitURL: "http://localhost:" + port + "/crashreporter",
                    extra: {
                        githuburl: "https://github.com/kamesh-a",
                        email: "kamesh.arumugam@a-cti.com",
                        contact: "+919884228421",
                        crashreport: "Please contact us regarding this report "
                    }
                });
            }
        });
    },
    init: function() {
        this.getPort();
    }
};

util.windowEvents = {
    show: function(containerName) {
        if (containerName) {
            FULLClient.ipc.send({
                title: containerName,
                eType: "windowEvents",
                opt: "show"
            });
        }
    },
    focus: function(containerName) {
        if (containerName) {
            FULLClient.ipc.send({
                title: containerName,
                eType: "windowEvents",
                opt: "focus"
            });
        }
    },
    restore: function(containerName) {
        if (containerName) {
            FULLClient.ipc.send({
                title: containerName,
                eType: "windowEvents",
                opt: "restore"
            });
        }
    },
    minimize: function(containerName) {
        if (containerName) {
            FULLClient.ipc.send({
                title: containerName,
                eType: "windowEvents",
                opt: "minimize"
            });
        }
    },
    hide: function(containerName) {
        if (containerName) {
            FULLClient.ipc.send({
                title: containerName,
                eType: "windowEvents",
                opt: "hide"
            });
        }
    }
};

util.config = {
    getSBurl: function() {
        return FULLClient.getConfig().sb5;
    },
    getOldV2url: function() {
        var config = FULLClient.getConfig().v2;
        if (typeof config == "string") return config; else if (typeof config == "object") return config.old;
    },
    getV2url: function() {
        var config = FULLClient.getConfig().v2;
        if (typeof config == "string") return config; else if (typeof config == "object") return config.new;
    }
};

util.mouse = {
    callback: null,
    registerCB: function(fn, context) {
        if (fn && typeof fn == "function") {
            this.callback = fn;
        }
    },
    execute: function(type) {
        if (this.callback) {
            this.callback.call(null, {
                etype: "contextmenu",
                action: "click",
                menu: type
            });
        } else if (type) {
            switch (type) {
              case "cut":
                {
                    util.publish("/tab/controller/mouse/" + type);
                    break;
                }

              case "copy":
                {
                    util.publish("/tab/controller/mouse/" + type);
                    break;
                }

              case "paste":
                {
                    util.publish("/tab/controller/mouse/" + type);
                    break;
                }

              case "replace":
                {
                    util.publish("/tab/controller/mouse/" + type);
                    break;
                }

              default:
                {
                    break;
                }
            }
        }
    }
};

util.app = {
    restart: function() {
        util.flush();
        util.publish("/app/restart/commence");
    },
    update: function() {
        if (util.window.getName() != namespace.CONTAINER_SB) {
            util.publish("/asar/update/commence");
        } else {
            FULLClient.ipc.sendToChat({
                mode: FULLClient.getMode(),
                name: "setMode"
            });
        }
    }
};

util.checkForUpdates = {
    isFromMenu: function() {
        var update = util.storage.get("update");
        if (update && update.checkForUpdates) return true; else return false;
    },
    setFlag: function(bool) {
        util.storage.set("update", {
            checkForUpdates: bool
        });
    }
};

util.zoom = {
    zoomInEnabled: true,
    zoomOutEnabled: true,
    updateUIOnFocus: function(win) {
        var contact = userDAO.getUser();
        if (contact) {
            if (win) {
                if (!win.zoomLevel) {
                    this.enableBothForcibly();
                } else if (win.zoomLevel == namespace.ZOOMOUT_LIMIT) {
                    this.disableInUI(namespace.ZOOMOUT);
                    this.enableZoomIn(true);
                } else if (win.zoomLevel == namespace.ZOOMIN_LIMIT) {
                    this.disableInUI(namespace.ZOOMIN);
                    this.enableZoomOut(true);
                } else {
                    this.enableBothForcibly();
                }
            }
        }
    },
    disableAllOnClearCache: function() {
        this.postToBackground(namespace.DISABLE, namespace.ALL);
        this.setFlag(namespace.ZOOMIN, false);
        this.setFlag(namespace.ZOOMOUT, false);
    },
    enableBoth: function() {
        this.enableZoomIn();
        this.enableZoomOut();
    },
    enableBothForcibly: function() {
        this.postToBackground(namespace.ENABLE, namespace.BOTH);
        this.setFlag(namespace.ZOOMIN, true);
        this.setFlag(namespace.ZOOMOUT, true);
    },
    enableZoomIn: function(isForce) {
        if (isForce || !this.zoomInEnabled) {
            this.postToBackground(namespace.ENABLE, namespace.ZOOMIN);
            this.setFlag(namespace.ZOOMIN, true);
        }
    },
    enableZoomOut: function(isForce) {
        if (isForce || !this.zoomOutEnabled) {
            this.postToBackground(namespace.ENABLE, namespace.ZOOMOUT);
            this.setFlag(namespace.ZOOMOUT, true);
        }
    },
    disableInUI: function(zoomType) {
        this.postToBackground(namespace.DISABLE, zoomType);
        this.setFlag(zoomType, false);
    },
    setFlag: function(zoomType, bool) {
        if (zoomType == namespace.ZOOMIN) {
            this.zoomInEnabled = bool;
        } else {
            this.zoomOutEnabled = bool;
        }
    },
    postToBackground: function(switchType, option) {
        if (switchType && option) {
            var bg = new PostToBackground("menuActions");
            bg[bg.choice].opt = switchType + option;
            FULLClient.emitter.sendToMain(bg[bg.choice]);
        }
    },
    getActiveTab: function() {
        var tab = util.tabs && util.tabs.getActiveTab() || document.querySelector("webview#LoginModule");
        return tab;
    },
    isUnderThreshold: function(zoomLevel) {
        if (zoomLevel >= namespace.ZOOMOUT_LIMIT && zoomLevel <= namespace.ZOOMIN_LIMIT) {
            return true;
        } else {
            return false;
        }
    },
    isAtThreshold: function(zoomLevel) {
        if (zoomLevel == namespace.ZOOMOUT_LIMIT || zoomLevel == namespace.ZOOMIN_LIMIT) {
            return true;
        } else {
            return false;
        }
    },
    setZoomLevel: function(win, zoomLevel, zoomType) {
        if (this.isUnderThreshold(zoomLevel)) {
            win.setZoomLevel(zoomLevel);
            win.zoomLevel = zoomLevel;
            if (this.isAtThreshold(zoomLevel)) {
                this.disableInUI(zoomType);
            }
        }
    },
    zoomIn: function(win) {
        if (win) {
            if (!win.zoomLevel) {
                win.zoomLevel = namespace.ZOOM_ACTUAL_SIZE;
            }
            this.enableZoomOut();
            this.setZoomLevel(win, win.zoomLevel + namespace.ZOOM_FACTOR, namespace.ZOOMIN);
        }
    },
    zoomOut: function(win) {
        if (win) {
            if (!win.zoomLevel) {
                win.zoomLevel = namespace.ZOOM_ACTUAL_SIZE;
            }
            this.enableZoomIn();
            this.setZoomLevel(win, win.zoomLevel - namespace.ZOOM_FACTOR, namespace.ZOOMOUT);
        }
    },
    resetZoom: function(win) {
        if (win) {
            this.enableBoth();
            win.setZoomLevel(namespace.ZOOM_ACTUAL_SIZE);
            win.zoomLevel = namespace.ZOOM_ACTUAL_SIZE;
        }
    }
};

util.subscribe("/util/menu/disableAll/onClearCache", util.zoom, util.zoom.disableAllOnClearCache);

util.engine = {
    getMinorVersion: function() {
        return parseInt(process.versions["electron"].split(".")[1]);
    },
    getMajorVersion: function() {
        return parseInt(process.versions["electron"].split(".")[0]);
    }
};

util.subscribe("/util/window/events/show", util.windowEvents, util.windowEvents.show);

util.subscribe("/util/window/events/hide", util.windowEvents, util.windowEvents.hide);

util.subscribe("/util/window/events/restore", util.windowEvents, util.windowEvents.restore);

util.subscribe("/util/window/events/focus", util.windowEvents, util.windowEvents.focus);

util.subscribe("/util/window/events/minimize", util.windowEvents, util.windowEvents.minimize);

util.init = function() {
    this.crashReporter.init();
    this.notification.prevent();
};

util.subscribe("/util/crashreporter/set/port", util.crashReporter, util.crashReporter.setPort);

util.subscribe("/util/v2/push/original/event", util.v2, util.v2.passOriginalEvent);

util.subscribe("/util/v2/statusPush", util.v2, util.v2.statusPush);

util.subscribe("/util/v2/dialNumber", util.v2, util.v2.dial);

util.subscribe("/util/v2/windows/caching/reset", util.caching.windows, util.caching.windows.reset);

var namespace = {
    APP_ID: /^win/.test(process.platform) && /FULLClient/.test(process.execPath) ? "FULL" : "AnywhereWorks",
    HIDDEN_CONTAINER: "HiddenWindow",
    CONTAINER_CHAT: "AnyWhereWorks",
    CONTAINER_CHAT_ALIAS: "Chat",
    CONTAINER_SB: "FULL",
    CONTAINER_V2: "V2",
    CONTAINER_TIMER: "Timer",
    CONTAINER_V2_SOFTPHONE: "V2SoftPhone",
    ZOOMIN: "ZoomIn",
    ZOOMOUT: "ZoomOut",
    ENABLE: "enable",
    DISABLE: "disable",
    BOTH: "Both",
    ALL: "All",
    ZOOMIN_LIMIT: 9,
    ZOOMOUT_LIMIT: -8,
    ZOOM_ACTUAL_SIZE: 0,
    ZOOM_FACTOR: 1
};

function PostToBackground(operationType) {
    this.name = "PostToBackground";
    this.choice = operationType;
    this.menuActions = {
        name: "menuActions",
        eType: "menuActions",
        opt: null
    };
}

var analytics = {
    TAB_LOAD: "TabLoad",
    TAB_ONLOAD: "TabOnload",
    FETCH: "Fetch",
    TAB_CLOSE: "TabClose",
    TAB_XCLOSE: "TabXClose",
    TAB_XCLOSE_Cancel: "TabXClosePopupCancel",
    V2_CLOSED: "V2Closed",
    RELOAD_V2: "ReloadV2",
    APP_CLEAR_CACHE: "AppClearCache",
    BACKUP_FORM: "BackUpForm",
    APP_ABNORMAL_QUIT: "AppCrashed",
    APP_CLOSED: "AppClosed",
    FULLCREATIVE_PAGE: "FULLCreativeWebsite",
    INCOGNITO_LINK: "IncognitoLinkLoaded",
    TIMERWIDGET_DROPDOWN: "TimerDropDown",
    TIMERWIDGET_TAB_DROPDOWN: "TabTimerDropDown",
    MAX_LOADED_TABS: "MaxLoadedTab",
    CHAT_ICON_CLICKED: "ChatIconClicked",
    REFETCH_RECENT_CLICKED: "RefetchRecentClicked",
    FEEDBACK_CLICKED: "FeedbackClicked",
    SENDING_FEEDBACK_BEGIN: "SendingFeedbackBegin",
    FEEDBACK_SUCCESS: "FeedbackSentSuccessfully",
    FEEDBACK_FAILED: "FeedbackFailed",
    NETWORK_STRENGTH_CLICKED: "NetworkStrengthClicked",
    UPDATE_BTN_CLICKED: "UpdateButtonClicked",
    UPDATE_LATER_CLICKED: "UpdateLaterClicked",
    WIPE_DATA: "AppWipeData"
};

function ImageCapture(frameName, encodedImg, feedbackId) {
    this.name = "image";
    this.frame = frameName;
    this.img = encodedImg;
    this.parentId = feedbackId;
}

function TabLock(text, isInformational) {
    if (typeof text != "string") {
        return {};
    }
    this.name = "tabLock";
    this.url = location.href;
    this.enableLock = true;
    this.dialog = {
        informational: isInformational ? true : false,
        text: text ? text : "Do you wish to force close the tab?"
    };
}

function TimerCommunication(opt, connId) {
    this.name = "TimerCommunication";
    this.setOperation.apply(this, arguments);
    this.setConnectionInfo = {
        name: "setConnectionInfo",
        DAIM: null
    };
    this.updateConnectionInfo = {
        name: "updateConnectionInfo",
        DAIM: null,
        status: null
    };
    this.closeConnection = {
        name: "closeConnection"
    };
}

TimerCommunication.prototype.setOperation = function(opt, connId) {
    if (opt && connId && new RegExp(opt, "ig").test([ "setConnectionInfo", "updateConnectionInfo", "closeConnection" ])) {
        this.opt = opt;
        this.connId = connId;
        return true;
    }
    throw new Error("Specified Operation is not available");
};

function SBcommunication(operationType) {
    if (operationType) operationCycle = operationType; else operationCycle = null;
    this.name = "sbCommunication";
    this.opt = operationCycle;
    this.accountOpt = {
        url: "",
        name: "accountOpt",
        opt: null
    };
    this.resizeContainer = {
        name: "resizeContainer",
        w: null,
        h: null
    };
    this.statusPush = {
        name: "statusPush",
        status: null
    };
}

function V2Communication(operationType) {
    var v2Options = [ "statusPush", "outbound", "getStatus", "reloadJS", "close" ], statusTypes = {
        name: "statusTypes",
        _available: "Available",
        _break: "Break",
        _meeting: "Meeting",
        _systemissues: "System",
        _personaltime: "Personal",
        _offline: "Offline"
    };
    var sbOpt = {
        name: "sbOpt",
        account: "accountOpt",
        status: "statusPush",
        _event: "_event",
        webtab: "webtab"
    };
    if (operationType) operationCycle = operationType; else operationCycle = v2Options;
    this.name = "v2Communication";
    this.opt = operationCycle;
    this.resizeContainer = {
        name: "resizeContainer",
        w: null,
        h: null
    };
    this.visibility = {
        name: "visibility",
        isShow: false
    };
    this.statusPush = statusTypes;
    this.isInterruptible = false;
    this.getStatus = v2Options;
    this.outbound = {
        name: "outbound",
        phoneNumber: ""
    };
    this.queryAndGetTabSource = {
        name: "queryAndGetTabSource",
        paramName: null,
        paramValue: null
    };
    this.close = false;
}

function WidgetTimer(operationType) {
    var operation = operationType ? operationType : false;
    this.name = "widgettimer";
    this.opt = operation;
    this.toWidgetContainer = {
        name: "toWidgetContainer",
        data: {}
    };
    this.toSbwindow = {
        name: "toSbwindow",
        data: {}
    };
    this.setHeightWidth = {
        name: "setHeightWidth",
        data: {}
    };
}

function ClientListener(lOperation) {
    var operation = lOperation ? lOperation : false;
    this.name = "clientlistener";
    this.opt = operation;
    this.count = {
        name: "count",
        target: "chat",
        count: undefined
    };
    this.showUpdatePopup = {
        name: "showUpdatePopup",
        domain: location.origin,
        gitRepoName: null,
        version: null,
        restartBtnName: null,
        cancelBtnName: null
    };
    this.hideUpdatePopup = {
        name: "hideUpdatePopup"
    };
    this.restartBtnClick = {
        name: "restartBtnClick"
    };
    this.cancelBtnClick = {
        name: "cancelBtnClick"
    };
    this.extensions = {
        name: "extensions",
        emittype: undefined,
        message: undefined
    };
    this.accessToken = {
        name: "accessToken",
        token: null
    };
    this.blur = {
        name: "blur",
        domain: location.origin
    };
    this.focus = {
        name: "focus",
        domain: location.origin
    };
    this.badgelabel = {
        name: "badgelabel",
        count: undefined
    };
    this.notify = {
        name: "notify",
        title: undefined,
        body: undefined,
        sec: undefined,
        icon: undefined
    };
    this.show = {
        name: "show",
        target: "chat"
    };
    this.hide = {
        name: "hide",
        target: "chat"
    };
    this.getstate = {
        name: "getstate"
    };
    this.requestattention = {
        name: "requestattention",
        isContinuous: false
    };
    this.restart = {
        name: "restart"
    };
    this.readFromClipboard = {
        name: "readFromClipboard"
    };
    this.loadwebsite = {
        name: "loadwebsite",
        isFullwork: undefined,
        isBrowserLoad: undefined,
        url: undefined
    };
    this.loadaccount = {
        name: "loadaccount",
        accountnumber: undefined
    };
    this.goclock = {
        name: "goclock",
        isStop: undefined,
        daim: 0
    };
    this.enableOnTop = {
        name: "enableOnTop"
    };
    this.disableOnTop = {
        name: "disableOnTop"
    };
    this.storeinbuffer = {
        name: "storeinbuffer",
        value: null
    };
    this.setv2status = {
        name: "setv2status",
        status: null
    };
    this.getv2status = {
        name: "getv2status"
    };
    this.download = {
        name: "download",
        filename: undefined,
        mimetype: undefined,
        url: undefined,
        contentlength: undefined,
        isViewable: false
    };
    this.toGuestPage = {
        name: "toGuestPage",
        guest: {
            source: location.href,
            destination: null
        },
        data: {}
    };
}

function Application(opt) {
    this.name = "Application";
    this.apps = {
        v2: "v2container",
        ibr: "inbuiltrouting",
        ic: "inbuiltchat",
        ch: "chatclient",
        sb: "sbcontainer",
        sp: "statuspanel",
        afk: "awayfromkeyboard",
        ecm: "enablecallcenterchatmode",
        mop: "menuoptions"
    };
    this.opt = opt ? opt : "open";
    this.close = {
        name: "close",
        appname: false
    };
    this.hide = {
        name: "hide",
        appname: false
    };
    this.show = {
        name: "show",
        appname: false
    };
    this.open = {
        name: "open",
        appname: false
    };
    this.quit = {
        name: "quit",
        callee: false
    };
    this.maximize = {
        name: "maximize",
        callee: false
    };
    this.collectfeedback = {
        name: "collectfeedback",
        userFeedback: null,
        isFromChatModule: false
    };
    this.clearCache = {
        name: "clearCache"
    };
    this.checkForUpdates = {
        name: "checkForUpdates"
    };
    this.onFocus = {
        name: "onFocus"
    };
    this.zoomIn = {
        name: "zoomIn"
    };
    this.zoomOut = {
        name: "zoomOut"
    };
    this.resetZoom = {
        name: "resetZoom"
    };
    this.menuoptions = {
        name: "menuoptions",
        opt: undefined,
        showoption: {
            name: "showoption",
            optionname: undefined
        },
        hideoption: {
            name: "hideoption",
            optionname: undefined
        }
    };
}

function LogsAck(id) {
    this.name = "captureLogs";
    this.opt = "captureLogs";
    this["captureLogs"] = {
        uniqueId: id
    };
    this["clearLogs"] = {
        name: "clearLogs"
    };
}

function LogACK(opt) {
    this.name = "LogACK";
    this.opt = opt;
    this["captureLogs"] = {
        name: "captureLogs",
        uniqueId: null
    };
    this["clearLogs"] = {
        name: "clearLogs"
    };
}

function Thinclient(lOpt, eventType, extension) {
    this.name = "thinclient";
    this.opt = lOpt ? lOpt : false;
    this.state = {
        name: "state",
        origin: null,
        visible: false,
        ext: extension ? extension : "chat",
        etype: eventType ? eventType : "click",
        extIsHide: false,
        window: {
            isMinimized: false,
            isBlured: false,
            isFocused: false
        }
    };
    this.menu = {
        name: "menuevent",
        metainfo: {
            menu: null,
            menuitem: null,
            eventType: "click"
        }
    };
    this.v2Status = {
        name: "v2Status",
        status: null
    };
    this.readFromClipboard = {
        name: "readFromClipboard",
        text: null,
        type: null,
        image: {
            dataUri: null,
            size: null,
            isEmpty: true
        }
    };
    this.extensions = {
        name: "extensions",
        type: undefined,
        message: undefined
    };
    this.notify = {
        name: "notify",
        isEvent: false
    };
    this.afk = {
        name: "afk",
        status: "user-away"
    };
    this.tabSourceQueryResult = {
        name: "tabSourceQueryResult",
        result: {
            src: null,
            params: null
        },
        query: {}
    };
    this.networkDetection = {
        name: "networkDetection",
        isUp: true
    };
    this.downloadFileInfo = {
        name: "downloadFileInfo",
        originalObject: null,
        downloadedPercentage: null,
        downloadedMB: null
    };
}

(function(R) {
    var projectMap = {
        default: null,
        answerconnectId: "YH0D44",
        adaptavantId: "91dfed2f-d29f-4302-89ee-341e9364b941"
    };
    var accessModifier = {
        mask: {
            enumerable: false,
            writable: true,
            configurable: false
        },
        protected: {
            enumerable: true,
            writable: false,
            configurable: false
        },
        private: {
            enumerable: false,
            writable: false,
            configurable: false
        }
    };
    var self = userInfoObject = {
        user: {},
        loggedIn: false,
        setloggedIn: function(flag) {
            this.loggedIn = flag;
        },
        isloggedIn: function() {
            return this.loggedIn;
        },
        isUserObjectValid: function(lUserInfo) {
            lUserInfo = lUserInfo || this.user;
            return lUserInfo && lUserInfo["success"] && lUserInfo["contact"] && lUserInfo["contact"].login ? true : false;
        },
        getContactLocalStorage: function() {
            try {
                return Locstor.get("userContactInfo");
            } catch (e) {
                console.error("Exception while getting in LocalStorage, User INFO : " + e.message);
                console.error("Exception while getting in LocalStorage, User INFO : ", e.stack);
                return {};
            }
        },
        setContactLocalStorage: function(user) {
            try {
                return Locstor.set("userContactInfo", user);
            } catch (e) {
                console.error("Exception while setting in LocalStorage, User INFO : " + e.message);
                console.error("Exception while setting in LocalStorage, User INFO : ", e.stack);
                return false;
            }
        },
        setV2Login: function(login) {
            var user = this.getContactLocalStorage();
            if (login && user && user.contact) {
                user.contact.v2Login = login;
                return this.setUser(user);
            }
        },
        getUserDcmResponse: function() {
            try {
                if (self.isUserObjectValid(self.user) || self.isUserObjectValid(self.user = self.getContactLocalStorage())) return self.user;
            } catch (userInfoException) {
                console.error(userInfoException.message);
                console.error(userInfoException.stack);
            }
            return false;
        },
        getAccessToken: function() {
            return this.user["accessToken"] || this.getContactLocalStorage()["accessToken"];
        },
        setAccessToken: function(token) {
            console.warn("We are trying to set Access token ", token);
            if (token && this.user) {
                this.user["accessToken"] = token;
                this.setUser(this.user);
                return this.user["accessToken"];
            }
        },
        getUser: function() {
            try {
                if (self.isUserObjectValid(self.user) || self.isUserObjectValid(self.user = self.getContactLocalStorage())) return self.user.contact;
            } catch (userInfoException) {
                console.error(userInfoException.message);
                console.error(userInfoException.stack);
            }
            return false;
        },
        setUser: function(userObject) {
            try {
                if (typeof userObject == "object" && this.isUserObjectValid(userObject)) {
                    self.user = userObject;
                    self.user.contact ? function() {
                        self.user.contact.email = self.user.contact.login;
                        self.user.contact.fullname = self.user.contact.fullName = self.user.contact.firstName + " " + self.user.contact.lastName;
                    }() : false;
                    self.setContactLocalStorage(self.user);
                    return self.getUserDcmResponse();
                } else {
                    return false;
                }
            } catch (userInfoException) {
                console.error("Error While Setting User Object : " + userInfoException.message);
                console.error("Error While Setting User Object : ", userInfoException.stack);
                return false;
            }
        },
        getUserContactSkillSet: function() {
            try {
                if (self.isUserObjectValid(self.user) || self.isUserObjectValid(self.user = self.getContactLocalStorage())) return self.user.contactSkillSet;
            } catch (userInfoException) {
                console.error(userInfoException.message);
                console.error(userInfoException.stack);
            }
            return false;
        },
        getUserSkillSet: function() {
            try {
                if (self.isUserObjectValid(self.user) || self.isUserObjectValid(self.user = self.getContactLocalStorage())) return self.user.skillSet;
            } catch (userInfoException) {
                console.error(userInfoException.message);
                console.error(userInfoException.stack);
            }
            return false;
        },
        getSkillByType: function(type, typeValue, queryType) {
            if (!typeValue || !type || !queryType) return false;
            try {
                var tmpSkillObj, skillSetArray = this[queryType]();
                if (skillSetArray && skillSetArray.length) {
                    for (var i = skillSetArray.length - 1; i >= 0; i--) {
                        tmpSkillObj = skillSetArray[i];
                        if (typeof tmpSkillObj == "object" && tmpSkillObj[type] == typeValue.trim()) {
                            return tmpSkillObj;
                        }
                    }
                }
                return false;
            } catch (userInfoException) {
                console.error(userInfoException.message);
                console.error(userInfoException.stack);
            }
        },
        patch: function(skillName) {
            var skill = this.getSkillByType("title", skillName, "getUserSkillSet");
            return skill ? this.getSkillById(skill.skillSetId) : false;
        },
        getSkillByName: function(skillName) {
            var tmp = this.patch(skillName);
            if (skillName == "FullWork") return tmp || this.patch("CEA") || {}; else return tmp;
        },
        getSkillById: function(id) {
            return this.getSkillByType("skillSetID", id, "getUserContactSkillSet");
        },
        getCompanyId: function() {
            if (projectMap["default"]) return projectMap["default"];
            var skillObj = self.getSkillById("98223b25-b41c-4c7e-bb91-569003f4cc45");
            projectMap["default"] = skillObj && skillObj.accountID ? skillObj.accountID : projectMap.answerconnectId;
            return projectMap["default"];
        },
        updateUserInfoViaApi: function(email) {
            return $.ajax({
                url: "https://live-contactsapi.appspot.com/services/signin/v2.0/Account/authenticate_v2?apikey=SEN42",
                type: "POST",
                data: '{"login":"' + (this.getEmail() || email) + '"}',
                contentType: "application/json"
            }).done(function(json) {
                this.setUser(json);
            }.bind(this));
        },
        getEmail: function() {
            var tmp = this.getUser();
            return tmp ? tmp.email : false;
        },
        getV2Login: function() {
            var tmp = this.getUser();
            return tmp ? tmp.v2Login : false;
        },
        clear: function() {
            this.user = null;
        }
    };
    R["userDAO"] = userInfoObject;
    for (var prop in userInfoObject) {
        if (userInfoObject.hasOwnProperty(prop)) {
            if ([ "loggedIn", "user" ].indexOf(prop) != -1) Object.defineProperty(userInfoObject, prop, accessModifier.mask); else Object.defineProperty(userInfoObject, prop, accessModifier.protected);
        }
    }
    Object.defineProperty(R, "userDAO", accessModifier.protected);
    util.subscribe("/user/info/update/via/api", userInfoObject, userInfoObject.updateUserInfoViaApi);
})(this);

(function(util) {
    var fullAuth = {
        isValid: function(obj) {
            if (obj && typeof obj == "object" && obj.contact) return true;
            throw new Error("Object is not valid user contact");
        },
        getAccessToken: function(exchangeCode) {
            if (exchangeCode) {
                return $.ajax({
                    type: "POST",
                    url: FULLClient.getConfig().auth.tokenUrl,
                    data: {
                        code: exchangeCode.replace(/#/, ""),
                        client_id: FULLClient.getConfig().auth.clientId,
                        client_secret: FULLClient.getConfig().auth.secret,
                        grant_type: "authorization_code",
                        redirect_uri: FULLClient.getConfig().auth.redirect
                    }
                });
            }
            throw new Error("Invalid exchange code key" + exchangeCode);
        },
        getContact: function(accessToken) {
            if (accessToken) {
                return $.ajax({
                    type: "GET",
                    url: FULLClient.getConfig().dcmApi.contact,
                    headers: {
                        Authorization: "Bearer " + accessToken
                    }
                });
            }
            throw new Error("Invalid accessToken " + accessToken);
        },
        getContactSkillSetAndSkillSet: function(contact) {
            if (contact && contact.id && contact.accountID) {
                return $.ajax({
                    type: "GET",
                    url: FULLClient.getConfig().dcmApi.skillSets + "?apikey=" + contact.accountID + "&contactID=" + contact.id
                });
            }
            throw new Error("Invalid accessToken " + contact);
        },
        aggregate: function(exchangeCode, callback) {
            var user = {};
            console.log("Access Code ", exchangeCode, callback);
            return $.when(this.getAccessToken(exchangeCode)).then(function(tokenObj) {
                console.log("stage 1 : ", tokenObj);
                user.accessToken = tokenObj.access_token;
                return this.getContact(tokenObj.access_token);
            }.bind(this)).then(function(contactResp) {
                user.contact = contactResp.data;
                console.log("stage 2 : ", user);
                return this.getContactSkillSetAndSkillSet(user.contact);
            }.bind(this)).then(function(res) {
                var resp;
                user.contactSkillSet = res.contactSkillSet;
                user.skillSet = res.skillSet;
                user.success = true;
                resp = fullAuth.isValid(user) ? user : {
                    success: false
                };
                console.log("stage 3 : ", resp, callback);
                if (callback && typeof callback == "function") {
                    callback.call(null, resp);
                }
                return resp;
            }).fail(function(r) {
                console.error("ERROR : ", r);
                callback.call(null, r);
            });
        }
    };
    util.subscribe("/services/fullauth/get/user", fullAuth, fullAuth.aggregate);
    module.exports = fullAuth;
})(util);

(function(root, util, undefined) {
    var urlParser = FULLClient.require("url");
    function getExeScript(srcInWebview) {
        var url = "images.sb.a-cti.com/chrome/js/webviewAPI.js";
        var _scriptString = 'var _webivewSupport=document.createElement("script");';
        if (srcInWebview && /^https/.test(srcInWebview)) _scriptString += '_webivewSupport.src="https://commondatastorage.googleapis.com/' + url + '";'; else _scriptString += '_webivewSupport.src="http://' + url + '";';
        _scriptString += '_webivewSupport.type="text/javascript";';
        _scriptString += "document.body.appendChild(_webivewSupport);";
        return _scriptString;
    }
    root["getExecuteScript"] = getExeScript;
    var isNWCompatible = function() {
        return true;
    };
    function WebviewProxy(id, sourceUrl, partitionName) {
        this._createWebviewDom(id, sourceUrl, partitionName);
    }
    WebviewProxy.prototype = {
        constructor: WebviewProxy,
        _createWebviewDom: function(id, sourceUrl, partitionName) {
            if (this.isNWCompatible()) {
                var webPage = document.createElement("webview");
                webPage.src = sourceUrl;
                webPage.id = id;
                this.id = id.replace(/[a-z]*/, "");
                this.callbackRegister = {};
                this._webview = webPage;
                this.setWidth("100%");
                this.setHeight("100%");
                this.setUserAgent();
                this.setPreload("../assets/js/preload/preloadWebview.js");
                this.setNewWinPolicy(webviewController.checkBrowserCompatible);
                this.setMediaControl();
                this.setLoadRedirect();
                this.setDisableWebSecurity();
                this.setMessageListener();
                this.setCrashListeners();
                this.setLoadAborted(webviewController.loadAbort);
                this.setContentloaded(this.setContextMenu.bind(this));
                this.setFindInPage();
            }
        },
        setCB: function(eventName, cb) {
            if (eventName) {
                return this.callbackRegister[eventName] = cb;
            }
        },
        getCB: function(eventName) {
            if (eventName) {
                return this.callbackRegister[eventName];
            }
        },
        setCB: function(eventName, cb) {
            if (eventName) {
                return this.callbackRegister[eventName] = cb;
            }
        },
        getCB: function(eventName) {
            if (eventName) {
                return this.callbackRegister[eventName];
            }
        },
        isNWCompatible: function() {
            return true;
        },
        getView: function() {
            return this._webview;
        },
        setHidden: function() {
            this.getView().removeAttribute("style");
            this.getView().setAttribute("class", "webview_hide");
        },
        setContextMenu: function() {
            if (this.isNWCompatible() && !this.getView().dataset.contextMenuEnabled) {
                this.getView().getWebContents().on("context-menu", function(event, param) {
                    util.publish("/context/menu/event/", event, param);
                });
                this.getView().dataset.contextMenuEnabled = true;
            }
        },
        setHeight: function(width) {
            if (this.isNWCompatible()) {
                this.getView().style.width = width;
            }
        },
        setWidth: function(height) {
            if (this.isNWCompatible()) {
                this.getView().style.height = height;
            }
        },
        setUserAgent: function() {
            if (this.isNWCompatible()) {
                this.getView().setAttribute("useragent", nwUserAgent);
            }
        },
        setDisableWebSecurity: function() {
            if (this.isNWCompatible()) {
                this.getView().setAttribute("disablewebsecurity", true);
            }
        },
        setMediaControl: function() {
            if (this.isNWCompatible()) {
                this.getView().addEventListener("permissionrequest", function(e) {
                    if (e.permission) {
                        e.request.allow();
                    }
                });
            }
        },
        setLoadRedirect: function() {
            if (this.isNWCompatible()) {
                var self = this;
                this.getView().addEventListener("did-get-redirect-request", function(evt) {
                    if (evt.isMainFrame) {
                        var oldUrlObject = urlParser.parse(evt.oldUrl || evt.oldURL);
                        var newUrlObject = urlParser.parse(evt.newUrl || evt.newURL);
                        console.debug("[" + self.id + "] [mainframe = " + evt.isMainFrame + "] LoadRedirect : oldUrl: " + oldUrlObject.host + ", newUrl : " + newUrlObject.host);
                        util.publish("webview/service/domain/redirect", self.id, newUrlObject);
                    }
                });
            }
        },
        setPreload: function(preloadScriptPath) {
            if (this.isNWCompatible()) {
                this.getView().setAttribute("preload", preloadScriptPath || "../asar/full.asar/webPreload.min.js");
            }
        },
        setLoadstart: function(cb) {
            if (cb && this.isNWCompatible()) {
                this._webview.addEventListener("did-start-loading", cb);
                this.setCB("did-start-loading", cb);
            }
        },
        setLoadstop: function(cb) {
            if (cb && this.isNWCompatible()) {
                this._webview.addEventListener("did-stop-loading", cb);
                this.setCB("did-stop-loading", cb);
            }
        },
        setContentloaded: function(cb) {
            if (cb && this.isNWCompatible()) {
                this._webview.addEventListener("did-finish-load", cb);
                this.setCB("did-finish-load", cb);
            }
        },
        setFrameFinishLoad: function(cb) {
            if (cb && this.isNWCompatible()) {
                this._webview.addEventListener("did-frame-finish-load", cb);
                this.setCB("did-frame-finish-load", cb);
            }
        },
        setDomReady: function(cb) {
            if (cb && this.isNWCompatible()) {
                this._webview.addEventListener("dom-ready", cb);
                this.setCB("dom-ready", cb);
            }
        },
        setDialogController: function(cb) {
            if (cb && this.isNWCompatible()) {
                this._webview.addEventListener("dialog", cb);
                this.setCB("dialog", cb);
            }
        },
        setNewWinPolicy: function(cb) {
            if (cb && this.isNWCompatible()) {
                this._webview.addEventListener("new-window", cb);
                this.setCB("new-window", cb);
            }
        },
        setLoadAborted: function(cb) {
            if (cb && this.isNWCompatible()) {
                this._webview.addEventListener("did-fail-load", cb);
                this.setCB("did-fail-load", cb);
            }
        },
        setResponsive: function(cb) {
            if (cb && this.isNWCompatible()) {
                this._webview.addEventListener("responsive", cb);
                this.setCB("responsive", cb);
            }
        },
        reload: function() {
            var src = this.getView().src;
            var view = new WebviewProxy(this.getView().id, src, this.partition);
            view.setContentloaded(this.getCB("did-finish-load"));
            var parent = $(this.getView()).parent();
            parent.children().remove("webview");
            parent.append(view.getView());
        },
        restore: function() {
            if (/&currentTabIndex=/.test(this.getView().src) && !/&isCrashed/.test(this.getView().src)) {
                this.getView().src += "&isCrashed=true";
                console.log("Appending crash param : " + this.getView().src);
            } else this.reload();
        },
        setCrashListeners: function() {
            function listener(e) {
                console.error("Crashed : ", e);
                util.preventEvent(e);
                this.restore();
            }
            this._webview.addEventListener("crashed", listener.bind(this));
            this._webview.addEventListener("gpu-crashed", listener.bind(this));
            this._webview.addEventListener("plugin-crashed", listener.bind(this));
            this._webview.addEventListener("destroyed", listener.bind(this));
        },
        setUnresponsive: function(cb) {
            if (cb && this.isNWCompatible()) {
                this.getView().addEventListener("crashed", cb);
            }
        },
        setMessageListener: function() {
            console.log("view : ", this.getView());
            this.getView().addEventListener("ipc-message", function(event) {
                console.log("Message from Webview ...", event.channel, ":", event.args[0]);
                util.publish("/msgModule/handler/", event.args[0], event.channel);
            });
        },
        setNodeIntegration: function() {
            this.getView().setAttribute("nodeintegration", true);
        },
        setFindInPage: function() {
            this.getView().addEventListener("found-in-page", function(e) {
                util.publish("/webview/found/in/page/", e);
            });
        }
    };
    root["WebviewProxy"] = WebviewProxy;
    root["webviewController"] = webviewController;
    var webviewController = {
        counter: 1,
        backUpDomain: [ "jersey", "setmore" ],
        urlFetchedDomain: [],
        errList: [ "ERR_ABORTED", "ERR_CONNECTION_CLOSED", "ERR_BLOCKED_BY_CLIENT", "ERR_ADDRESS_UNREACHABLE", "ERR_EMPTY_RESPONSE", "ERR_FILE_NOT_FOUND", "ERR_UNKNOWN_URL_SCHEME" ],
        loadAbort: function(event, errorCode, errorDescription, validatedURL, isMainFrame) {
            var e = event;
            console.check("did failed to load : ", event, errorCode, errorDescription, validatedURL, isMainFrame);
            console.debug("\n LoadAbort url: " + e.url + "\n LoadAbort toplevel : " + e.isTopLevel + "\n LoadAbort code: " + e.code + "\n LoadAbort reason: " + e.reason);
            if (e.isTopLevel && !e.target.getAttribute("isReloaded") && webviewController.errList.indexOf(e.reason) == -1) {
                console.warn("Reloading the Webview !!! ");
                e.target.stop ? e.target.stop() : false;
                e.target.reload ? e.target.reload() : false;
                e.target.setAttribute("isReloaded", true);
            }
        },
        getDomainsLoadableInBrowser: function() {
            if (this.urlFetchedDomain.length) return this.urlFetchedDomain; else return [];
        },
        initialCallForSpreadSheetUrl: function() {
            this.getUrlFromSpreadSheet(this.addUrls);
        },
        getUrlFromSpreadSheet: function(cb) {
            $.post("https://script.google.com/macros/s/AKfycbxg0brhayGhgksKPdn9_Ku379GehCIRiMDiNhYkA3jrHftF1RU/exec").done(function(response) {
                if (response) {
                    cb.call(this, response);
                }
            }.bind(this)).fail(function(err) {
                console.error("Error in getting Urls from spreadsheet :", err);
            });
        },
        addUrls: function(jsobj) {
            util.publish("/open/browse/private/whitelist", jsobj);
        },
        checkBrowserCompatible: function(e) {
            e.preventDefault();
            e.cancelBubble = true;
            util.publish("/open/browse/private/window", e);
        },
        openNewWindow: function(e) {
            e.cancelBubble = true;
            if (e && e.url) {
                console.log("NewWindowEvent, opening : " + e.url);
                if (e.target.src.indexOf(FULLClient.getConfig().chat) != -1) {
                    util.loadWebSiteInBrowser(e.url);
                    return true;
                }
                util.loadWebSiteInNewWindow(e.url);
                return true;
            }
        },
        loadStart: function(e) {
            root["test"][webviewController.counter++] = e;
        }
    };
    util.subscribe("/webview/controller/app/onload", webviewController, webviewController.initialCallForSpreadSheetUrl);
})(this, util);

console.log("Chat container...", nwUserAgent);

(function(R, util) {
    var clientlistener = {
        handler: function(msg) {
            console.log("handler :", msg);
            var val = msg.opt.trim();
            switch (val) {
              case "accessToken":
                {
                    console.log("Setting Access Token ", msg[msg.opt].token);
                    userDAO.setAccessToken(msg[msg.opt].token);
                    break;
                }

              case "showUpdatePopup":
                {
                    util.publish("updateUI/guestPage/msgHandler", msg[msg.opt]);
                    break;
                }

              case "readFromClipboard":
                {
                    chat.postToWebview(util.clipboard.read());
                    break;
                }

              case "getv2status":
                {
                    var toChat = new Thinclient("v2Status");
                    toChat[toChat.opt].status = util.v2.getV2LastReceivedStatus();
                    chat.postToWebview(toChat);
                    break;
                }

              case "showsbcontainer":
                {
                    util.publish("/util/window/events/show", namespace.CONTAINER_SB);
                    break;
                }

              case "toGuestPage":
                {
                    chat.postToWebview(msg);
                    break;
                }

              case "setv2status":
                {
                    FULLClient.emitter.sendToSB(msg);
                    break;
                }

              case "feedback":
                {
                    var feedbackSend = new Application("collectfeedback");
                    console.log("Feedback text:", msg[msg.opt].text);
                    feedbackSend[feedbackSend.opt].userFeedback = msg[msg.opt].text;
                    feedbackSend[feedbackSend.opt].isFromChatModule = true;
                    feedbackSend[feedbackSend.opt].token = msg[msg.opt].token;
                    FULLClient.emitter.sendToSB(feedbackSend);
                    break;
                }

              case "notify":
                {
                    util.publish("/notification/create/show", msg);
                    break;
                }

              case "clearCache":
                {
                    console.log("ClearCache: user doing sign-out in chat window.");
                    FULLClient.emitter.sendToSB({
                        name: "analytics",
                        accountNumber: null,
                        eventAction: analytics.APP_CLEAR_CACHE,
                        connId: FULLClient.getMode() + " " + FULLClient.getManifest().version + " " + process.platform,
                        metaInfo: "Clearing Cache for App from chatwindow"
                    });
                    util.clear();
                    break;
                }

              case "show":
                {
                    chat.postToBackground(namespace.CONTAINER_CHAT, "windowEvents", "show");
                    break;
                }

              case "hide":
                {
                    chat.postToBackground(namespace.CONTAINER_CHAT, "windowEvents", "hide");
                    break;
                }

              case "restart":
                {
                    chat.reloadchat();
                    break;
                }

              case "quit":
                {
                    var commObj = {
                        name: "appQuit",
                        sender: namespace.CONTAINER_CHAT
                    };
                    FULLClient.emitter.sendToSB(commObj);
                    break;
                }

              case "getstate":
                {
                    chat.send_state();
                    break;
                }

              case "download":
                {
                    util.publish("/file/download/Start/", msg[msg.opt]);
                    break;
                }

              case "badgelabel":
              case "count":
                {
                    if (/^win32/.test(process.platform)) msg[msg.opt].count ? util.showBadgeLabel(msg[msg.opt].count.toString()) : util.showBadgeLabel(""); else chat.postToBackground(namespace.CONTAINER_CHAT, "setBadge", "", msg[msg.opt].count);
                    break;
                }

              case "requestattention":
                {
                    if (/^darwin/.test(process.platform)) {
                        chat.postToBackground(namespace.CONTAINER_CHAT, "bounce", msg[msg.opt].isContinuous);
                    } else {
                        chat.postToBackground(namespace.CONTAINER_CHAT, "windowEvents", "bounce");
                    }
                    break;
                }

              case "enableOnTop":
                {
                    chat.postToBackground(namespace.CONTAINER_CHAT, "windowEvents", "enableontop");
                    break;
                }

              case "restore":
                {
                    chat.postToBackground(namespace.CONTAINER_CHAT, "windowEvents", "restore");
                    break;
                }

              case "maximize":
                {
                    chat.postToBackground(namespace.CONTAINER_CHAT, "windowEvents", "maximize");
                    break;
                }

              case "disableOnTop":
                {
                    chat.postToBackground(namespace.CONTAINER_CHAT, "windowEvents", "disableontop");
                    break;
                }

              case "loadwebsite":
                {
                    FULLClient.emitter.sendToMediator(msg);
                    break;
                }

              default:
                {
                    console.warn("Unknown routine in channel listener ", msg);
                    break;
                }
            }
        }
    };
    var application = {
        handler: function(msg) {
            if (msg.opt) {
                switch (msg.opt) {
                  case "onFocus":
                    {
                        util.zoom.updateUIOnFocus(chat.getView());
                        break;
                    }

                  case "zoomIn":
                    {
                        util.zoom.zoomIn(chat.getView());
                        break;
                    }

                  case "resetZoom":
                    {
                        util.zoom.resetZoom(chat.getView());
                        break;
                    }

                  case "zoomOut":
                    {
                        util.zoom.zoomOut(chat.getView());
                        break;
                    }

                  case "checkForUpdates":
                    {
                        console.log("checkForUpdates");
                        util.publish("guestPage/checkUpdate/onMenuClick");
                        util.storage.set("update", {
                            checkForUpdates: true
                        });
                        break;
                    }

                  case "default":
                    {
                        console.log("Default capture in Application event", msg);
                        break;
                    }
                }
            }
        }
    };
    var msgModule = {
        name: "MessageModule",
        log: function() {
            util.log.apply(this, arguments);
        },
        proxy: function() {
            msgModule.handler.apply(msgModule, arguments);
        },
        handler: function(e) {
            var msg = arguments[0].name ? arguments[0] : arguments[1];
            var name = msg.name ? msg.name.toLowerCase() : false;
            console.log("Message Recieved asa: ", msg);
            switch (name) {
              case "fulloauth":
                {
                    this.log("Recieved message on fulloauth block : ", msg);
                    util.publish("/app/loginModule/msg/recieved", msg);
                    break;
                }

              case "oauth":
                {
                    this.log("NEW oAuth implementation ", msg);
                    util.publish("/services/fullauth/get/user", msg.code, function cb(user) {
                        console.log("new oAuth callback called ", user);
                        util.publish("/app/loginModule/msg/recieved", {
                            contact: user
                        });
                    });
                    break;
                }

              case "wipedata":
                {
                    util.publish("/app/user/data/wipe");
                    break;
                }

              case "relogin":
                {
                    console.log("No Operation");
                    break;
                }

              case "crashreporter":
                {
                    util.publish("/util/crashreporter/set/port", msg.port);
                    break;
                }

              case "capturelogs":
                {
                    chat.postToWebview(msg);
                    break;
                }

              case "application":
                {
                    application.handler(msg);
                    break;
                }

              case "thinclient":
                {
                    chat.postToWebview(msg);
                    break;
                }

              case "windowstate":
                {
                    chat.postToWebview(msg);
                    break;
                }

              case "appquit":
                {
                    $("webview").remove();
                    window.removeEventListener("beforeunload", chat.onbeforeunload);
                    chat.isQuitable = true;
                    window.close();
                    break;
                }

              case "clientlistener":
                {
                    clientlistener.handler(msg);
                    break;
                }

              case "setmode":
                {
                    FULLClient.setMode(msg.mode);
                    break;
                }

              default:
                {
                    msgModule.log("Default Sequence Capture this : ", msg);
                    break;
                }
            }
        }
    };
    var ipc = FULLClient.require("electron").ipcRenderer;
    ipc.on("msg-to-Chat", msgModule.handler.bind(msgModule));
    util.subscribe("/msgModule/handler/", msgModule, msgModule.handler);
})(this, util);

var chat = {
    toDropEvent: false,
    isQuitable: false,
    outerDiv: null,
    appurl: null,
    onloadDFD: $.Deferred(),
    initObj: {
        name: "init",
        opt: "chat",
        dcm: null
    },
    name: "chatMsgHandler",
    setZoomLevelLimits: function() {
        util.getCurrentWindow().webContents.setZoomLevelLimits(1, 1);
    },
    onload: function() {
        chat.setZoomLevelLimits();
        chat.onloadDFD.resolve("Webview onload success");
        chat.postToWebview(chat.initObj);
        chat.registerMouse();
        jQuery(window).bind("resize", jQuery.debounce(20, false, function(event) {
            console.log("On resize");
            chat.getOuterDiv().height(window.innerHeight);
        }));
        window.onfocus = function() {
            var webView = chat.getView();
            if (webView) {
                util.document.shadowRootFocus(webView);
                util.zoom.updateUIOnFocus(webView);
            }
        };
    },
    log: function() {
        util.log.apply(this, arguments);
    },
    _canQuit: function(flag) {
        this.isQuitable = flag;
    },
    getView: function() {
        return document.querySelector("webview#chat_webview");
    },
    send_state: function(opt) {
        var commObj = {
            eType: "getState",
            opt: namespace.CONTAINER_CHAT
        };
        FULLClient.ipc.send(commObj);
    },
    getOuterDiv: function() {
        if (!this.outerDiv) this.outerDiv = $("#chatContainer");
        return this.outerDiv;
    },
    getUrl: function() {
        if (this.appurl) return this.appurl; else {
            console.log("getting url for chat  ? ", FULLClient.getConfig());
            this.appurl = FULLClient.getConfig().chat + userDAO.getUser().email + "&uniquepin=" + userDAO.getCompanyId() + "&isSingleWindow=false";
            return this.appurl;
        }
    },
    mouseMenu: function(evt) {
        if (evt && evt.menu) {
            this.getView()[evt.menu]();
        }
    },
    reloadchat: function() {
        chat.postToBackground(namespace.CONTAINER_CHAT, "windowEvents", "show");
        var chatView = this.getView();
        if (chatView) chatView.reload();
    },
    registerMouse: function() {
        util.mouse.registerCB(this.mouseMenu, this);
    },
    onbeforeunload: function(e) {
        console.log("onbefore unload is getting trigger ");
        function onQuit() {
            if (/^win/.test(process.platform)) {
                console.log("minimizing window...");
                chat.postToBackground(namespace.CONTAINER_CHAT, "windowEvents", "minimize");
            } else {
                console.log("Hiding window...");
                chat.postToBackground(namespace.CONTAINER_CHAT, "windowEvents", "hide");
            }
        }
        if (!chat.isQuitable) {
            onQuit();
            return chat.isQuitable;
        } else {
            console.log("We are letting window to close ");
            return undefined;
        }
    },
    onClose: function() {
        window.onbeforeunload = this.onbeforeunload;
    },
    postToWebview: function(obj) {
        this.onloadDFD.done(function() {
            console.log("Posting to webview ... ", obj);
            var dom = chat.getView();
            if (dom && obj) {
                dom.send("webapp-msg", obj);
            }
        });
    },
    postToBackground: function(title, eType, opt, count) {
        var commObj = {
            title: title ? title : namespace.CONTAINER_CHAT,
            eType: eType ? eType : false,
            opt: opt ? opt : false,
            count: count ? count : 0
        };
        if (commObj && commObj.eType) {
            FULLClient.emitter.sendToMain(commObj);
        }
    },
    sendToHost: function() {
        messenger.broadCast(namespace.Mediator, msg);
    },
    init: function() {
        chat._canQuit(false);
        this.initObj.dcm = JSON.stringify(userDAO.getUserDcmResponse());
        this.createChatFrame(this.getUrl());
        Locstor.set("v2", null);
    },
    createChatFrame: function(url) {
        var chatDom = new WebviewProxy("chat_webview", url, "FULLClient:Chat");
        chatDom.setContentloaded(chat.onload);
        this.getOuterDiv().html(chatDom.getView());
    },
    messageListener: function(event) {
        console.log("Message received as ", event);
    }
};

FULLClient.emitter.subscribe(namespace.CHAT, chat.messageListener);

util.subscribe("/chat/quit/flag", chat, chat._canQuit);

util.subscribe("/chat/start", chat, chat.init);

(function(util) {
    var asarUpdater = {
        manifestUpdate: null,
        manifest: null,
        extractPath: null,
        pathVersion: null,
        getJsonURL: function() {
            return "https://storage.googleapis.com/images.sb.a-cti.com/TC/electron/" + FULLClient.getMode() + "/asar/0.2.0/asarUpdater.json";
        },
        hashCheck: function() {
            if (FULLClient.getMode() != "code") {
                $.getJSON(this.getJsonURL(), function(data) {
                    console.warn("Asar Updater response : ", data);
                    this.manifest = FULLClient["manifest"];
                    if (this.manifest.checkSum !== data["checkSum"]) this.calculatePath(data); else {
                        console.log("Asar Updation : Your app is upto date");
                        util.publish("/app/updater/start", {
                            asarUpdated: false
                        });
                    }
                }.bind(this));
            }
            return true;
        },
        getSemVer: function(arg) {
            return /([0-9]{0,}\.[0-9]{0,})/.exec(arg)[0];
        },
        calculatePath: function(res) {
            var path = FULLClient.require("path"), packVer = this.getSemVer(FULLClient.getManifest().main), cloudVer = this.getSemVer(res["asarVersion"]), manifest = FULLClient.getManifest().main;
            if (compareVersions(packVer, cloudVer) == 0) {
                var patch = /[0-9]*\.[0-9]*\.[0-9]*/.exec(manifest)[0], patch = ++patch.split(".")[2], folderVer = packVer + "." + patch;
                this.extractPath = path.join(FULLClient.getFilePath(), res["asarPackage"], folderVer);
                this.pathVersion = path.join(res["asarPackage"], folderVer);
                this.versionCheck(res);
            } else {
                this.extractPath = path.join(FULLClient.getFilePath(), res["asarPackage"], res["asarVersion"]);
                this.pathVersion = path.join(res["asarPackage"], res["asarVersion"]);
                this.versionCheck(res);
            }
        },
        versionCheck: function(res) {
            var path = FULLClient.require("path");
            this.manifest.main = path.join(this.pathVersion, "full.asar", "background.js");
            this.manifest.preloadUrl = path.join(this.pathVersion, "full.asar", "preload.min.js");
            this.manifest.checkSum = res["checkSum"];
            this.startUpdate(res["asarDownloadURI"]);
        },
        startUpdate: function(url) {
            util.publish("/download/helper/file/download", {
                url: url,
                callback: this.downloadCB,
                mimetype: "application/zip",
                context: this
            });
        },
        downloadCB: function(err, filePath) {
            if (err) {
                this.sendErrMail(err);
                console.warn("Asar Updater : Error in downloading");
                return;
            }
            util.publish("/download/helper/zip/extractWithADM", {
                fd: filePath,
                context: this,
                callback: this.excractCB,
                extractPath: this.extractPath
            });
        },
        excractCB: function(err, stdout, stderr) {
            if (err) {
                this.sendErrMail(err);
                console.warn("Asar Updater : Error in Extracting");
                return;
            }
            util.publish("/download/helper/file/write", {
                fd: FULLClient.require("path").join(FULLClient.getFilePath(), "package.json"),
                context: this,
                callback: function() {
                    console.warn("Going to commence APP Update");
                    util.publish("/app/updater/start", {
                        asarUpdated: true
                    });
                }
            }, JSON.stringify(this.manifest));
        },
        sendErrMail: function(errObj) {
            var tmp = {
                subject: "Asar Updation Error",
                type: "Error Log",
                err: errObj
            };
            util.publish("/mailHelper/mailsend", tmp);
        }
    };
    module.exports = asarUpdater;
    util.subscribe("/asar/update/commence", asarUpdater, asarUpdater.hashCheck);
})(util);

(function(util) {
    var path = FULLClient.require("path");
    var appUpdates = {
        updateManifest: null,
        isAsarRestartRequired: null,
        _queuedRestart: function() {
            if (this.isAsarRestartRequired) {
                util.publish("/app/restart/commence");
            } else {
                console.log("no app update and asar update avaialble..");
                if (util.checkForUpdates.isFromMenu()) {
                    util.checkForUpdates.setFlag(false);
                    alert("Your App is Already Updated..");
                }
            }
        },
        start: function(asarObj) {
            this.isAsarRestartRequired = asarObj ? asarObj.asarUpdated : false;
            if (FULLClient.getMode() != "code") {
                var jsonFetchUrl = "https://storage.googleapis.com/images.sb.a-cti.com/TC/electron/" + FULLClient.getMode() + "/app/appUpdater.json";
                $.getJSON(jsonFetchUrl).done(function(res) {
                    this.checkVersion(res);
                }.bind(this)).fail(function(reason) {
                    console.error("AppUpdates Failed ", reason);
                    this._queuedRestart();
                }.bind(this));
            }
        },
        commenceDownload: function(manifest) {
            this.updateManifest = manifest;
            util.publish("/download/helper/file/download", {
                updateType: "app",
                url: manifest.downloadURL,
                callback: this.downloadCB,
                mimetype: "application/zip",
                context: this
            });
        },
        checkVersion: function(manifest) {
            var packageJSON = FULLClient.getManifest();
            if (manifest && manifest.version && packageJSON.version != manifest.version) {
                util.publish("updateUI/ShowUI/container", "appUpdate", manifest, this.commenceDownload, this);
            } else if (manifest.mode && util.scripts.get().src.indexOf(manifest.mode) == -1) {
                util.publish("updateUI/ShowUI/container", "appUpdate", manifest, this.commenceDownload, this);
            } else {
                this._queuedRestart();
            }
        },
        downloadCB: function(error, filePath) {
            if (error) {
                console.error("Error While Downloading : ", this.updateManifest);
                console.error("Reason : " + error.message);
                console.error("stack : ", error.stack);
                this._queuedRestart();
                return;
            }
            util.publish("/download/helper/zip/extract", {
                fd: filePath,
                context: this,
                callback: this.extractCB
            });
        },
        extractCB: function(error, stdout, stderr) {
            if (error) {
                console.error("Error While Extracting : ", this.updateManifest);
                console.error("Reason : " + error.message);
                console.error("stack : ", error.stack);
                util.publish("/mailHelper/mailsend", {
                    subject: "App Updater Failed ",
                    type: "Error Log",
                    err: error
                });
                this._queuedRestart();
                return;
            }
            this.versionUpdateInManifest();
        },
        versionUpdateInManifest: function() {
            var appManifest = FULLClient.getManifest();
            appManifest.version = this.updateManifest.version;
            util.publish("/download/helper/file/write", {
                fd: path.join(FULLClient.getFilePath(), "package.json"),
                callback: this.updateVersionInPlist,
                context: this
            }, JSON.stringify(appManifest));
        },
        pushLogsToDev: function(errLogs) {
            util.publish("/mailHelper/mailsend", {
                type: "Error Log",
                err: errLogs,
                subject: "App updater : failed while writing to info.plist for " + userDAO.getEmail()
            }, function callback() {
                console.warn("Error logs : ", errLogs);
                this.reload();
            }.bind(this));
        },
        plistParser: function(plistPath, data) {
            try {
                var plist = require("plist"), fs = require("fs"), appInfoPlist = plist.parse(data);
                appInfoPlist["CFBundleVersion"] = "64-bit";
                appInfoPlist["CFBundleShortVersionString"] = this.updateManifest.version;
                fs.writeFile(plistPath, plist.build(appInfoPlist), "utf8", function(err) {
                    if (err) this.pushLogsToDev(err); else this.reload();
                }.bind(this));
            } catch (e) {
                console.log("Error while parsing Info Plist :", e);
            }
        },
        updateVersionInPlist: function() {
            if (/^darwin/.test(process.platform)) {
                var fs = require("fs"), plistPath = FULLClient.getFilePath().replace("/Resources/app", "/Info.plist");
                fs.readFile(plistPath, "utf8", function(err, data) {
                    if (err) this.pushLogsToDev(err); else this.plistParser(plistPath, data);
                }.bind(this));
            } else this.reload();
        },
        reload: function(error) {
            if (error) {
                console.error("Error While updating manifest : ", this.updateManifest);
                console.error("Reason : " + error.message);
                console.error("stack : ", error.stack);
                this._queuedRestart();
                return;
            }
            util.publish("/app/restart/commence");
        }
    };
    util.subscribe("/app/updater/start", appUpdates, appUpdates.start);
})(util);

(function(util) {
    var fs = FULLClient.require("fs"), http = FULLClient.require("http"), https = require("https");
    path = FULLClient.require("path");
    var downloadHelper = {
        retries: 0,
        download: function(paramObj) {
            console.log("URL in update Helper to download : ", paramObj);
            if (paramObj.url && util.isUrl(paramObj.url)) {
                var url = paramObj.url.replace(/(http:\/\/images.sb.a-cti.com)/, "https://storage.googleapis.com/images.sb.a-cti.com");
                var filename = path.basename(url);
                var tmpPath = paramObj.downloadPath || FULLClient.getFilePath();
                var downloadFilePath = path.join(tmpPath, filename);
                var http = util.isHttps(url) ? https : http;
                console.log("File downloadURL  :: " + url);
                console.log("File path to download :: " + downloadFilePath);
                var file;
                http.get(url, function(res) {
                    if (paramObj.mimetype == res.headers["content-type"]) {
                        file = fs.createWriteStream(downloadFilePath, {
                            autoClose: true
                        });
                        var downloadPercentage = 0, previousPercentage = 0, progressUIShown = false, currentPercentage;
                        res.on("data", function(chunk) {
                            if (paramObj.updateType && paramObj.updateType == "app") {
                                if (!progressUIShown) {
                                    progressUIShown = true;
                                    util.publish("updateUI/hideDownloadWinandshowProgress");
                                }
                                downloadPercentage += chunk.length;
                                currentPercentage = Math.floor(downloadPercentage / res.headers["content-length"] * 100);
                                if (previousPercentage != currentPercentage) {
                                    previousPercentage = currentPercentage;
                                    util.publish("progressUI/updatePercentage", previousPercentage);
                                }
                            }
                        }.bind(this));
                        file.on("finish", function() {
                            console.log("Finished..!");
                            if (paramObj.updateType && paramObj.updateType == "app") progressUIShown = false;
                            file.close();
                            setTimeout(function() {
                                if (paramObj.callback) paramObj.callback.apply(paramObj.context || null, [ null, downloadFilePath ]);
                            }, 6e3);
                        });
                        res.pipe(file);
                    }
                }.bind(this)).on("error", function(e) {
                    console.log("Error in downloading : " + e);
                    if (paramObj.callback) paramObj.callback.call(paramObj.context || null, e);
                });
            }
        },
        queuedRetries: function(paramObj) {
            if (this.retries <= 3 && paramObj) {
                setTimeout(function() {
                    this.extract(paramObj);
                }, this.retries++ * 3e3);
            }
        },
        extract: function(paramObj) {
            var unzipTool, src = paramObj.fd, dest = paramObj.extractPath || FULLClient.getFilePath(), child = FULLClient.require("child_process");
            if (path.extname(src) == ".zip") {
                if (/^win/.test(process.platform)) {
                    unzipTool = path.resolve(FULLClient.getFilePath(), "tools", "unzip.exe");
                } else if (/darwin/.test(process.platform)) {
                    unzipTool = "unzip";
                }
                console.warn("src : " + src + ", dest : " + dest);
                child.exec('"' + unzipTool + '" -oq "' + src + '" -d "' + dest + '" ', function(e, stdout, stderr) {
                    if (e) {
                        console.log("Error in Extraction : " + e);
                        console.warn("Queueing for retries.");
                        this.queuedRetries(paramObj);
                    } else if (paramObj.callback) {
                        console.log("Making retries 0, and proceeding with call back");
                        this.retries = 0;
                        paramObj.callback.apply(paramObj.context || null, [ e, stdout, stderr ]);
                    }
                }.bind(this));
            } else {
                if (paramObj.callback) paramObj.callback.apply(paramObj.context || null, [ new Error("Invalid zip file") ]);
            }
        },
        extractWithADM: function(paramObj) {
            try {
                console.warn("paramObj : ", paramObj);
                process.noAsar = true;
                var src = paramObj.fd, dest = paramObj.extractPath || FULLClient.getFilePath(), adm = FULLClient.require("adm-zip");
                paramObj.callback = paramObj.callback || function() {};
                if (path.extname(src) == ".zip") {
                    var zip = new adm(src);
                    if (!zip.isOriginalFs) {
                        console.log("Routing to older zip systeam, bcoz ADM zip not updated.");
                        return this.extract(paramObj);
                    }
                    console.warn("zip.isOriginalFs Available ");
                    zip.extractAllToAsync(dest, true, paramObj.callback.bind(paramObj.context));
                } else {
                    if (paramObj.callback) paramObj.callback.apply(paramObj.context || null, [ new Error("Invalid zip file") ]);
                }
            } catch (err) {
                console.warn("Error in extractWithADM routing to extract");
                this.extract(paramObj);
            }
        },
        writeToFileSystem: function(paramObj, dataToWrite) {
            if (paramObj && paramObj.fd && dataToWrite) {
                fs.writeFile(paramObj.fd, dataToWrite, function(err) {
                    if (paramObj && typeof paramObj.callback == "function") {
                        paramObj.callback.apply(paramObj.context || null, [ err || null, "success" ]);
                    }
                });
            } else if (paramObj && typeof paramObj.callback == "function") {
                paramObj.callback.call(paramObj.context || null, new Error("Invalid param , while writing into file"));
            }
        }
    };
    module.exports = downloadHelper;
    util.subscribe("/download/helper/file/download", downloadHelper, downloadHelper.download);
    util.subscribe("/download/helper/zip/extract", downloadHelper, downloadHelper.extract);
    util.subscribe("/download/helper/zip/extractWithADM", downloadHelper, downloadHelper.extractWithADM);
    util.subscribe("/download/helper/file/write", downloadHelper, downloadHelper.writeToFileSystem);
})(util);

(function(R, util) {
    var restart = {
        getScriptName: function() {
            var scriptname;
            switch (FULLClient.getAppName().toLowerCase()) {
              case "fullclient-electron.exe":
                {
                    scriptname = "fc.bat";
                    break;
                }

              case "anywhereworks.exe":
                {
                    scriptname = "aww.bat";
                    break;
                }

              case "anywhere works.exe":
                {
                    scriptname = "awwspaced.bat";
                    break;
                }

              case "aww-v2.exe":
                {
                    scriptname = "aww-v2.bat";
                    break;
                }

              default:
                {
                    scriptname = "aww.bat";
                    break;
                }
            }
            return scriptname;
        },
        quitApp: function() {
            util.publish("/app/restore/removeAll", "tabs");
            var child = require("child_process").exec, path = require("path");
            if (/^win/.test(process.platform)) {
                var quietTool = path.resolve(process.resourcesPath, "app", "tools", "Quiet.exe");
                var scriptPath = path.resolve(process.resourcesPath, "app", "scripts", this.getScriptName());
                child('START " "  "' + quietTool + '"  "' + scriptPath + '"', function(err) {
                    if (err) console.log("Error in restart" + err);
                });
            } else if (/^darwin/.test(process.platform)) {
                var applicationPath, endIndex = process.resourcesPath.indexOf("/Contents");
                var appName = namespace.APP_ID == "FULL" ? "FULLClient-Electron" : FULLClient.getAppName();
                var scriptPath = path.resolve(process.resourcesPath, "app", "scripts", "restart.sh");
                applicationPath = process.resourcesPath.substring(0, endIndex);
                appName = util.escapeSpaces(appName);
                scriptPath = util.escapeSpaces(scriptPath);
                applicationPath = util.escapeSpaces(applicationPath);
                console.log("ApplicationPath to START : " + applicationPath);
                var daemon = child("sh " + scriptPath + " " + process.pid + " " + applicationPath + " " + appName, function(err, stdout, stderr) {
                    if (err) {
                        console.log(err);
                    }
                    console.debug("STDOUT :", stdout);
                    console.warn("STDERR : ", stderr);
                });
            }
        },
        initiate: function() {
            this.quitApp();
        }
    };
    util.subscribe("/app/restart/commence", restart, restart.initiate);
})(this, util);

(function(root, $, mediator) {
    process.on("uncaughtException", function(err) {
        console.log(err);
    });
    var loginDFD = $.Deferred();
    var onLoadDFD = $.Deferred();
    onload = function() {
        if (namespace.APP_ID != document.title) {
            document.title = namespace.APP_ID;
        }
        console.log("Onload in Chat container.. ..");
        amplify.publish("module/controller/onload", {
            source: "onload"
        });
    };
    var moduleLoader = {
        name: "ModuleLoader",
        log: function() {
            util.log.apply(this, arguments);
        }
    };
    moduleLoader.init = function() {
        mediator.publish("/app/loginModule/start", loginDFD);
        mediator.publish("/webview/controller/app/onload");
        $.when(loginDFD).done(function() {
            moduleLoader.skillBasedLoader();
            userDAO.setloggedIn(true);
        });
    };
    moduleLoader.onloadRecived = function(isDomReady) {
        if (isDomReady) onLoadDFD.resolveWith(moduleLoader, []);
        this.init();
        return onLoadDFD.promise();
    };
    moduleLoader.login = function() {
        if (userDAO.getUserDcmResponse()) loginDFD.resolveWith(moduleLoader, []);
        if (window.Locstor) /fullauth/.test(Locstor.get("recentRefetch")) ? Locstor.remove("recentRefetch") : false;
        return loginDFD.promise();
    };
    moduleLoader.skillBasedLoader = function() {
        FULLClient.emitter.sendToMain({
            eType: "init"
        });
        if (userDAO.getSkillByName("FullWork")) {
            this.chatMode();
        } else {
            util.publish("/asar/update/commence");
        }
        $("#v2_Phone_Icon").show();
    };
    moduleLoader.chatMode = function() {
        this.log("ChatMode");
        util.publish("/chat/start");
        util.publish("/start/engine/updater/");
    };
    moduleLoader.reset = function() {
        loginDFD = $.Deferred();
        this.init();
    };
    mediator.subscribe("module/controller/onload", moduleLoader, moduleLoader.onloadRecived);
    mediator.subscribe("module/controller/login", moduleLoader, moduleLoader.login);
    mediator.subscribe("module/controller/reset", moduleLoader, moduleLoader.reset);
})(window, jQuery, amplify);

(function(R, M) {
    var loginModule = {
        name: "loginModule",
        userLoginInfo: null,
        log: function() {
            util.log.apply(this, arguments);
        },
        getBaseURL: function() {
            return FULLClient.getConfig().login;
        },
        getServiceId: function() {
            return this.isNewFullAuth() ? FULLClient.getConfig().auth.clientId : FULLClient.getConfig().serviceId;
        },
        isNewFullAuth: function() {
            return /fullcreative.fullauth/.test(FULLClient.getConfig().login);
        },
        getLoginURL: function() {
            return this.isNewFullAuth() ? this.getBaseURL() + "/o/oauth2/auth?" + "state=oAuth" + "&client_id=" + this.getServiceId() + "&redirect_uri=" + this.getRedirectURL() + "&scope=contacts-api.full_access awapis.fullaccess" + "&response_type=code&approval_prompt=force&expiry_type=LONG" : this.getBaseURL() + "/oauth/2/authentication/fullOauthService?" + "serviceAccountId=" + this.getServiceId() + "&redirectUrl=" + this.getRedirectURL() + "&isTc=true" + "&errorUrl=" + this.getRedirectURL() + "&allowExternalUser=true";
        },
        getRedirectURL: function() {
            return this.isNewFullAuth() ? FULLClient.getConfig().auth.redirect : this.getBaseURL() + "/login.jsp";
        },
        onload: function(evt) {
            loginModule.log("Recieved login page onload !!! ", evt);
            util.publish("/app/loginModule/onload/recieved");
            evt.target.send("webapp-init", {
                name: "init",
                source: "FULL",
                contact: {}
            });
        },
        embedWebviewDom: function() {
            this.log("Embedding webview login dom ");
            var login = new WebviewProxy("LoginModule", this.getLoginURL(), "persist:FULLClient:tab");
            login.setContentloaded(this.onload);
            $("#chatContainer").append(login.getView());
        },
        getMainProcessUserInfo: function() {
            var tmp = userDAO.getUser();
            tmp.isFullWork = userDAO.getSkillByName("FullWork") ? true : false;
            tmp.isCEA = userDAO.getSkillByName("CEA") ? true : false;
            tmp["crashInfo"] = this.userLoginInfo ? this.userLoginInfo : null;
            return tmp;
        },
        getUserInfoFromUserLoginRegisterModule: function() {
            util.publish("/userInfo/getSpecDetails/", function(res) {
                if (res) {
                    this.userLoginInfo = res;
                }
            }.bind(this));
        },
        sendUserInfoToMainProcess: function() {
            console.log("sendUserInfoToMainProcess ...");
            FULLClient.emitter.sendToMain({
                eType: "userInfo",
                userObj: this.getMainProcessUserInfo()
            });
        },
        getLocalStorageUserData: function() {
            if (userDAO.getUser()) {
                this.log("USER Data available in storage !!!");
                util.publish("module/controller/login", {
                    source: "login",
                    data: "localStorage"
                });
                this.sendUserInfoToMainProcess();
                return true;
            } else {
                this.embedLoginTab();
                return false;
            }
        },
        embedLoginTab: function() {
            this.removedEmbeddedView();
            this.embedWebviewDom();
        },
        removedEmbeddedView: function() {
            $("#LoginModule").remove();
        },
        saveUser: function(contact) {
            var dcm = contact;
            if (dcm && dcm["success"] && dcm["contact"] && dcm["contact"].login) {
                this.removedEmbeddedView();
                this.log("FullOauth has contact,skillset and success param so persisting in localStorage ");
                userDAO.setUser(dcm);
                util.publish("module/controller/login", {
                    source: "login"
                });
                this.sendUserInfoToMainProcess();
                if (!userDAO.getSkillByName("FullWork")) {
                    util.publish("/util/window/events/hide", namespace.CONTAINER_CHAT);
                }
            } else {
                this.log("DCM data is NULL, so we are going to login page again !!!! ");
                util.cookies.clear();
                this.log("Application Cookies are cleared !!!");
            }
        },
        msgHandler: function(msg) {
            if (msg) {
                this.saveUser(msg.contact);
            }
        },
        init: function() {
            this.log(this.getLoginURL());
            this.getUserInfoFromUserLoginRegisterModule();
            this.getLocalStorageUserData();
        }
    };
    M.subscribe("/app/loginModule/start", loginModule, loginModule.init);
    M.subscribe("/app/loginModule/msg/recieved", loginModule, loginModule.msgHandler);
    R["loginModule"] = loginModule;
})(this, amplify, util);

(function(R, $, util) {
    var childProcess = require("child_process");
    var getOS = {
        getSystemInfo: function() {
            var defer = $.Deferred();
            childProcess.exec("systeminfo", function(error, sysout, syserr) {
                if (!error) {
                    console.log("System INFO :: ", sysout, syserr);
                    defer.resolve(sysout || syserr);
                }
                defer.reject(error);
            });
            return defer;
        },
        platform: function() {
            return process.platform == "darwin" ? this.mac() : this.win();
        },
        getRelease: function() {
            return FULLClient.require("os").release();
        },
        win: function() {
            var osVer = this.getRelease(), kernalVer = /\d*\.\d*/.exec(osVer)[0];
            switch (kernalVer) {
              case "10.0":
                return "Windows 10";

              case "6.3":
                return "Windows 8.1";

              case "6.2":
                return "Windows 8";

              case "6.1":
                return "Windows 7";

              case "6.0":
                return "Windows vista";

              default:
                return "OlderOrLatest";
            }
        },
        mac: function() {
            var kernalVer = this.getRelease(), kernalVer = /\d*/.exec(kernalVer)[0];
            switch (kernalVer) {
              case "13":
                return "Mavericks";

              case "14":
                return "Yosemite";

              case "15":
                return "El Capitan";

              case "16":
                return "Sierra";

              default:
                return "olderOrLatest";
            }
        }
    };
    try {
        var specs, os_details = FULLClient.require("os");
        specs = "Hostname         : " + os_details.hostname() + "\n OS platform      : " + getOS.platform() + "\n CPU model        : " + os_details.cpus()[0].model + "\n OS architecture  : " + os_details.arch() + "\n Total memory     : " + Math.round(os_details.totalmem() / (1024 * 1024 * 1024)) + "GB" + "\n Free Memory      : " + Math.round(os_details.freemem() / (1024 * 1024)) + "MB" + "\n Exec Path : " + process.execPath + "\n Env Path : " + process.env.PATH;
    } catch (e) {
        console.error("Exception while getting system info :: ", e.message);
        console.error("Exception while getting system info :: ", e.stack);
        console.error("Exception while getting system info :: ", e);
        specs = e.message + "\n" + e.stack;
    }
    var registerUser = {
        ip: "0.0.0.0",
        name: "RegisterUserInSpreadsheet",
        log: function() {
            util.log.apply(this, arguments);
        },
        setSpeckInfo: function(speckInfo) {
            return {
                version: "App : " + FULLClient.manifest.version + ", Engine : " + process.versions.electron,
                os: getOS.platform(),
                name: util.user.getEmail(),
                mode: FULLClient.getMode(),
                systeminfo: speckInfo || "Still Not Taken",
                ip: this.ip
            };
        },
        getSpecDetails: function(cb) {
            if (cb) {
                cb.call(this, {
                    appVersion: FULLClient.manifest.version,
                    engine: process.versions.electron,
                    platform: process.platform,
                    os: getOS.platform(),
                    mode: FULLClient.getMode(),
                    ipaddress: this.ip
                });
            }
        },
        getSpecks: function() {
            if (/^darwin/.test(process.platform)) {
                var defer = $.Deferred();
                defer.resolve(specs);
                return defer;
            } else if (/^win/.test(process.platform)) {
                return getOS.getSystemInfo();
            }
        },
        storeInSpreadsheet: function() {
            if (util.user.getEmail()) {
                this.log("Storing in Spreadsheet user info ");
                this.getSpecks().done(function(systemInfo) {
                    var info = registerUser.setSpeckInfo(systemInfo);
                    $.post("https://script.google.com/macros/s/AKfycbzyZf4grFPDwclO9WUtlfqW9-R4JRole_IWE0GXU-2pXhWvoPc/exec?", {
                        userInfo: JSON.stringify(info)
                    });
                }).fail(function(err) {
                    console.warn("User-system information collection error : ", err.message);
                    console.warn("User-system information collection error : ", err.stack);
                    var info = registerUser.setSpeckInfo(specs);
                    $.post("https://script.google.com/macros/s/AKfycbzyZf4grFPDwclO9WUtlfqW9-R4JRole_IWE0GXU-2pXhWvoPc/exec?", {
                        userInfo: JSON.stringify(info)
                    });
                });
            }
        },
        getIP: function() {
            $.get("http://l2.io/ip").done($.proxy(function(ipAddress) {
                this.log("Got IPAddress : " + ipAddress);
                this.ip = ipAddress;
            }, this)).fail($.proxy(function() {
                this.log("Getting IP address failed !!!");
            }, this)).then($.proxy(this.storeInSpreadsheet, this));
        }
    };
    module.exports = registerUser;
    util.subscribe("module/controller/login", registerUser, registerUser.getIP);
    util.subscribe("/userInfo/getSpecDetails/", registerUser, registerUser.getSpecDetails);
})(window, jQuery, util);

(function(R, util) {
    var EventEmitter = require("events").EventEmitter;
    var path = require("path");
    var win = util.getCurrentWindow();
    var remote = FULLClient.require("electron").remote;
    var dialog = remote.dialog;
    var fs = FULLClient.require("fs");
    var request = FULLClient.require("request");
    function FileDownloader(downloadItem) {
        EventEmitter.call(this);
        this.name = "fileDownloader";
        this.id = uuid.v4(new Date().getTime());
        this.requestObject = null;
        this.originalObject = downloadItem;
        this.getdownloadUrl = function() {
            return downloadItem.url ? downloadItem.url : null;
        };
        this.downloadFile = function(cb, requestErrorCallback, filePath) {
            this.requestObject = request(this.getdownloadUrl()).on("response", cb).pipe(fs.createWriteStream(filePath));
            this.requestObject.on("error", function(err) {
                if (err) {
                    console.log("Error in request:", err);
                    this.removeProgressBar();
                    requestErrorCallback.apply(this, [ {
                        err: err,
                        id: this.id,
                        originalObject: this.originalObject
                    } ]);
                }
            }.bind(this));
        };
        this.removeProgressBar = function() {
            win.setProgressBar(-1);
        };
        this.cancelDownload = function() {
            this.requestObject.emit("close");
            console.warn("Download Cancelling for [CLOSE]");
            this.requestObject.end("");
            console.warn("Download Cancelling for [end]");
            this.requestObject.close();
            console.warn("Download Cancelling for [destory]");
            console.log("Download canceled for [ ", this.id, " ]");
        };
        this.on(this.id, function() {
            console.warn("Cancel Event Emitted for :", this.id);
            this.cancelDownload();
        });
    }
    FileDownloader.prototype = Object.create(EventEmitter.prototype);
    var downloadController = {
        downloadMap: {},
        downloadActive: null,
        glen: null,
        chunkLength: null,
        downloadedPercentage: null,
        precision: null,
        customDownloadPath: false,
        previousPercentage: 0,
        responseObj: {},
        decider: function(downloadItem) {
            console.log("Getting request for download for chat : downloadActive :", this.downloadActive);
            if (!this.downloadActive && downloadItem && downloadItem.action != "cancel") {
                this.downloadActive = true;
                this.start(downloadItem);
            }
            if (downloadItem && downloadItem.action == "cancel") {
                var Obj = this.downloadMap[downloadItem.id];
                console.warn("Download Cancelling for [", downloadItem.id, " ]");
                Obj.emit(downloadItem.id);
                this.responseObj[downloadItem.id].destroy();
                this.sendCancelEventToChat(this.downloadMap[downloadItem.id]);
                this.downloadMap[downloadItem.id].originalObject.fileCancelled = true;
                process.nextTick(function() {
                    downloadController.deletefile(downloadItem.id, downloadController.removeLocalObj);
                });
            }
        },
        start: function(downloadItem) {
            var fileObj = path.parse(downloadItem.filename);
            console.info("FileObj:", fileObj.ext);
            var downloadObj = new FileDownloader(downloadItem);
            var dpath, options;
            options = {
                title: "Downloads",
                defaultPath: this.getDownloadFolder() + "/" + downloadItem.filename,
                filters: [ {
                    name: "All Files",
                    extensions: [ "*" ]
                } ]
            };
            dialog.showSaveDialog(options, function(data) {
                if (!data) {
                    console.log("User selected cancel button: ", data);
                    this.downloadActive = null;
                }
                if (data) {
                    this.downloadActive = null;
                    console.debug("User selected path :", data);
                    var filePath = this.getPathToWrite(data, fileObj.ext);
                    downloadObj.originalObject["downloadInfo"] = path.parse(filePath);
                    downloadObj.originalObject["fileInfo"] = fileObj;
                    downloadObj.downloadFile(function(res) {
                        this.responseObj[downloadObj.id] = res;
                        this.glen += parseInt(res.headers["content-length"], 10);
                        var downloadPercentage = 0;
                        console.debug("Written Path :", this.getPathToWrite(data, fileObj.ext));
                        res.on("data", function(chunk) {
                            try {
                                this.chunkLength += chunk.toString("utf8");
                                downloadPercentage += chunk.length;
                                this.calculatePercentageAndMegabyte(this.glen, this.chunkLength, downloadPercentage, res, downloadItem, downloadObj);
                            } catch (e) {}
                        }.bind(this));
                        res.on("error", function(err) {
                            if (err) {
                                console.error("Error while downloading...!", err.message);
                                console.error("Error while downloading...!", err.stack);
                                this.removeProgressBar();
                            }
                        }.bind(this));
                        res.on("end", function(err) {
                            if (err) {
                                console.log("Error at end:", err.message);
                                console.log("Error at end:", err.stack);
                                this.removeProgressBar();
                            }
                            var fileInfo = path.parse(data);
                            this.findOriginalObjectandCompleteEvent(res.request.href, fileInfo.base ? fileInfo.base : fileObj.base, downloadObj.id);
                            this.setDownloadPathinLocalStorage("lastDownloadedPath", fileInfo.dir);
                            if (fileInfo.dir && fileInfo.base && !downloadObj["originalObject"].fileCancelled) {
                                this.finishDownload("completed", fileInfo.ext ? fileInfo.base : fileInfo.base + fileObj.ext);
                            }
                        }.bind(this));
                    }.bind(this), this.requestErrorCallback, filePath);
                    this.downloadMap[downloadObj.id] = downloadObj;
                }
            }.bind(this));
        },
        findOriginalObjectandCompleteEvent: function(url, filename, fileId) {
            for (var i in this.downloadMap) {
                if (this.downloadMap[i].originalObject.url == url || this.downloadMap[i].originalObject.filename == filename) {
                    var fileInfo = new Thinclient("downloadFileInfo");
                    fileInfo[fileInfo.opt].originalObject = this.downloadMap[i].originalObject;
                    fileInfo[fileInfo.opt].id = this.downloadMap[i].id;
                    fileInfo[fileInfo.opt].status = "completed";
                    this.sendMessageToChat(fileInfo);
                    this.removeLocalObj(fileId);
                }
            }
        },
        removeLocalObj: function(fileId) {
            delete this.downloadMap[fileId];
            if ($.isEmptyObject(this.downloadMap)) {
                console.log("downloadMap is empty", this.downloadMap, ": we can clear dock...!");
                this.flushDockProgress();
            }
        },
        flushDockProgress: function() {
            this.precision = null;
            this.chunkLength = null;
            this.glen = null;
            this.removeProgressBar();
        },
        deletefile: function(fileId, cb) {
            var obj = this.downloadMap[fileId];
            var downloadInfo = obj.originalObject.downloadInfo;
            var originalInfo = obj.originalObject.fileInfo;
            var filePath;
            if (downloadInfo) {
                filePath = path.join(downloadInfo.dir, downloadInfo.name + (downloadInfo.ext || originalInfo.ext));
                console.warn("DOWNLOAD File-path to delete while CANCEL :", filePath);
            }
            if (filePath) {
                this.checkfileExistenceInUserSystem(filePath, function(path) {
                    fs.unlink(path, function(err) {
                        if (err) {
                            console.error("Error in deleting file:", err.message);
                            console.error("Error in deleting file:", err.stack);
                        } else {
                            console.warn("DOWNLOAD File-path to delete successful :", path);
                            cb.call(this, fileId);
                        }
                    }.bind(this));
                }.bind(this));
            }
        },
        checkfileExistenceInUserSystem: function(filePath, cb) {
            fs.stat(filePath, function(err, stats) {
                if (err) {
                    console.error("Error in getting " + filePath + "availibilty:", err);
                } else {
                    cb.call(this, filePath);
                }
            }.bind(this));
        },
        requestErrorCallback: function() {
            var errorInfo = arguments[0];
            delete downloadController.downloadMap[errorInfo.id];
            var fileInfo = new Thinclient("downloadFileInfo");
            fileInfo[fileInfo.opt].originalObject = errorInfo.originalObject;
            fileInfo[fileInfo.opt].id = errorInfo.id;
            fileInfo[fileInfo.opt].status = "failed";
            downloadController.sendMessageToChat(fileInfo);
        },
        sendCancelEventToChat: function(fileObj) {
            var fileInfo = new Thinclient("downloadFileInfo");
            fileInfo[fileInfo.opt].originalObject = fileObj;
            fileInfo[fileInfo.opt].id = fileObj.id;
            fileInfo[fileInfo.opt].status = "cancelled";
            this.sendMessageToChat(fileInfo);
        },
        getDownloadFolder: function() {
            var downloadFolderName = "Downloads";
            if ("HOME" in process.env) {
                return path.join(process.env.HOME, downloadFolderName);
            } else if ("HOMEPATH" in process.env) {
                return path.join(process.env.HOMEDRIVE, process.env.HOMEPATH, downloadFolderName);
            } else if ("USERPROFILE" in process.env) {
                return path.join(process.env.USERPROFILE, downloadFolderName);
            }
        },
        getDownLoadedPath: function(filename) {
            return path.join(this.getDownloadFolder(), filename);
        },
        getCustomDownLoadedPath: function(filename) {
            return path.join(this.getCachedDownloadedPath("lastDownloadedPath"), filename);
        },
        showInFolder: function(filename) {
            if (this.customDownloadPath) shell.showItemInFolder(this.getCustomDownLoadedPath(filename)); else shell.showItemInFolder(this.getDownLoadedPath(filename));
        },
        getCachedDownloadedPath: function(key) {
            return util.storage.get(key);
        },
        setDownloadPathinLocalStorage: function(key, value) {
            if (key && value) this.customDownloadPath = true;
            return util.storage.set(key, value);
        },
        updateProgressBar: function(percentage) {
            if (!/^darwin/.test(process.platform)) {
                setTimeout(function() {
                    win.setProgressBar(percentage);
                }, 0);
            }
        },
        removeProgressBar: function() {
            setTimeout(function() {
                win.setProgressBar(-1);
            }, 0);
        },
        finishDownload: function(state, filename) {
            if (state == "completed") {
                this.completed(filename);
            }
        },
        completed: function(filename) {
            this.showInFolder(filename);
            this.removeProgressBar();
        },
        getPathInfo: function(filepathInfo) {
            return path.parse(filepathInfo);
        },
        getPathToWrite: function(filepathInfo, savedfileObj) {
            var pathInfo = path.parse(filepathInfo);
            return path.join(pathInfo.dir, pathInfo.name + (pathInfo.ext || savedfileObj));
        },
        constructDownloadInfoObject: function(downloadItem, downloadObj, previousPercentage, downloadedMB) {
            var percent = new Thinclient("downloadFileInfo");
            percent[percent.opt].originalObject = downloadItem;
            percent[percent.opt].id = downloadObj.id;
            percent[percent.opt].downloadedPercentage = previousPercentage;
            percent[percent.opt].downloadedMB = downloadedMB;
            this.sendMessageToChat(percent);
        },
        sendMessageToChat: function(obj) {
            if (FULLClient && obj) {
                FULLClient.ipc.sendToChat(obj);
            }
        },
        calculatePercentageAndMegabyte: function(glen, chunkLength, downloadPercentage, res, downloadItem, downloadObj) {
            var currentPercentage, downloadedMB;
            currentPercentage = Math.floor(downloadPercentage / res.headers["content-length"] * 100);
            downloadedMB = (chunkLength.length / 1048576).toFixed(2);
            if (this.previousPercentage != currentPercentage) {
                this.previousPercentage = currentPercentage;
                this.downloadedPercentage = this.previousPercentage;
                this.constructDownloadInfoObject(downloadItem, downloadObj, this.previousPercentage, downloadedMB);
            }
            var downloaded = parseFloat((chunkLength.length / glen).toFixed(2));
            if (typeof downloaded == "number" && this.precision != downloaded) {
                this.updateProgressBar(downloaded);
            }
        }
    };
    R["downloadController"] = downloadController;
    module.exports.FileDownloader = FileDownloader;
    module.exports.downloadController = downloadController;
    util.subscribe("/file/download/Start/", downloadController, downloadController.decider);
})(this, util);

(function(R, $, util, undefined) {
    var fs = FULLClient.require("fs");
    var feedbackAlerted = false;
    try {
        var nodeNotifier = FULLClient.require("node-notifier");
        function FullNotification(clientListenerObj) {
            this.name = "FULLNotification";
            this.source = clientListenerObj != null ? clientListenerObj : location.origin;
            this.container = util.window.getName();
            this.title = this.getTitlefromObject();
            this.body = this.getBodyfromObject();
            this.icon = this.getIconfromObject();
            this.silent = this.getSilentOption();
            this.focusContainer = this.getfocusContainer();
            this.create();
        }
        FullNotification.prototype.create = function() {
            var options = {
                title: this.title,
                body: this.body,
                name: this.name,
                icon: this.icon,
                source: this.source,
                container: this.container,
                silent: this.silent,
                focusContainer: this.focusContainer
            };
            if (/^darwin/.test(process.platform)) {
                this.macNotification(options);
            } else if (/^win/.test(process.platform)) {
                this.windowsNotification(options);
            }
        };
        FullNotification.prototype._isValid = function() {
            if (this.source && this.source.notify) return true; else return false;
        };
        FullNotification.prototype.getTitlefromObject = function() {
            return this.source.notify.title && this._isValid() ? this.source.notify.title : "Fullclient_Title";
        };
        FullNotification.prototype.getBodyfromObject = function() {
            return this.source.notify.body && this._isValid() ? this.replaceSlash(this.source.notify.body) : "Fullclient_Message";
        };
        FullNotification.prototype.getIconfromObject = function() {
            return this.source.notify.icon && this._isValid() ? this.source.notify.icon : "";
        };
        FullNotification.prototype.getSilentOption = function() {
            return this.source.notify.silent || true;
        };
        FullNotification.prototype.getfocusContainer = function() {
            return this.source.notify.focusContainer || true;
        };
        FullNotification.prototype.replaceSlash = function(str) {
            return str.replace(/\\/g, ".").replace(/\r?\n|\r/g, ".");
        };
        FullNotification.prototype.macNotification = function(nObj) {
            var sourceObj, notificatioObj, containerName, options, _keys, _tc;
            if (nObj.source.name == "clientlistener" && nObj.source.opt == "notify" && nObj.source.notify) sourceObj = nObj.source.notify; else sourceObj = nObj.source;
            notificatioObj = this.getnotifyObject(sourceObj);
            if (notificationController.canUseTerminlNotifier) {
                this.macTerminalNotification(notificatioObj, nObj);
            } else {
                if (!feedbackAlerted) {
                    feedbackAlerted = true;
                    util.publish("/feedback/initiate", {
                        userFeedback: "System generated feedback, Notification is falling back to native notification scheme"
                    });
                }
            }
        };
        FullNotification.prototype.macTerminalNotification = function(notificatioObj, nObj) {
            var nc = new nodeNotifier.NotificationCenter();
            nc.notify({
                title: this.getTitle(nObj),
                message: this.getBody(nObj),
                contentImage: this.getIcon(nObj),
                remove: "ALL",
                wait: false
            }, function(err, response) {
                if (err) {
                    console.log("Error in macNotification:", err);
                }
                if (response.indexOf("Removing previously sent notification") != -1 && response.indexOf("Activate") != -1) {
                    nc.emit("click");
                }
            }.bind(this));
            nc.once("click", function(notifierObject, options) {
                var currentWin = util.getCurrentWindow();
                currentWin.setAlwaysOnTop(true);
                setTimeout(function() {
                    currentWin.setAlwaysOnTop(false);
                }.bind(this), 200);
                this.sendClickeventHelper(notificatioObj, nObj);
                notificationController.activeNotification = null;
            }.bind(this));
            nc.once("timeout", function(notifierObject, options) {
                notificationController.activeNotification = null;
            }.bind(this));
            setTimeout(function() {
                notificationController.activeNotification = null;
            }.bind(this), 3e3);
        };
        FullNotification.prototype.sendClickeventHelper = function(notificatioObj, nObj) {
            if (nObj.container && nObj.focusContainer) {
                this.showAppropriateWindow(nObj.container);
            }
            _tc = new Thinclient("notify");
            _tc[_tc.opt].isEvent = true;
            _keys = Object.keys(notificatioObj);
            for (var i = _keys.length - 1; i >= 0; i--) {
                _tc[_tc.opt][_keys[i]] = notificatioObj[_keys[i]];
            }
            _tc[_tc.opt].type = "click";
            this.sendClickEventToContainer(nObj.container, _tc);
        };
        FullNotification.prototype.windowsNotification = function(nObj) {
            var sourceObj, notificatioObj, containerName, _keys, _tc;
            var nc = new nodeNotifier.WindowsBalloon();
            if (nObj.source.name == "clientlistener" && nObj.source.opt == "notify" && nObj.source.notify) sourceObj = nObj.source.notify; else sourceObj = nObj.source;
            notificatioObj = this.getnotifyObject(sourceObj);
            setTimeout(function() {
                notificationController.activeNotification = null;
            }.bind(this), 3e3);
            nc.notify({
                title: this.getTitle(nObj),
                message: this.getBody(nObj),
                time: 3e3,
                wait: true
            }, function(error, response) {
                if (error) this.handlefullexception(error);
            }.bind(this)).on("click", function(arguments) {
                notificationController.activeNotification = null;
                var currentWin = util.getCurrentWindow();
                currentWin.setAlwaysOnTop(true);
                setTimeout(function() {
                    currentWin.setAlwaysOnTop(false);
                }.bind(this), 0);
                if (nObj.container && nObj.focusContainer) {
                    this.showAppropriateWindow(nObj.container);
                }
                _tc = new Thinclient("notify");
                _tc[_tc.opt].isEvent = true;
                _keys = Object.keys(notificatioObj);
                for (var i = _keys.length - 1; i >= 0; i--) {
                    _tc[_tc.opt][_keys[i]] = notificatioObj[_keys[i]];
                }
                _tc[_tc.opt].type = "click";
                this.sendClickEventToContainer(nObj.container, _tc);
            }.bind(this));
        };
        FullNotification.prototype.truncate = function(str, charRestrictionCount) {
            if (str && typeof str == "string") {
                if (charRestrictionCount && str.length > charRestrictionCount) {
                    return str.substr(0, charRestrictionCount);
                } else {
                    return str;
                }
            }
        };
        FullNotification.prototype.getnotifyObject = function(ClientListenerObject) {
            function notifyObject(ClientListenerObject) {
                var _keys = Object.keys(ClientListenerObject);
                for (var i = _keys.length - 1; i >= 0; i--) {
                    this[_keys[i]] = ClientListenerObject[_keys[i]];
                }
            }
            return new notifyObject(ClientListenerObject);
        };
        FullNotification.prototype.getTitle = function(nObj) {
            return this.truncate(nObj.title, 45);
        };
        FullNotification.prototype.getBody = function(nObj) {
            return this.truncate(nObj.body, 150);
        };
        FullNotification.prototype.getIcon = function(nObj) {
            return "";
        };
        FullNotification.prototype.getContainer = function() {
            if (this.source && this.source.notify.container) return this.source.notify.container; else return false;
        };
        FullNotification.prototype.showAppropriateWindow = function(containerName) {
            switch (containerName) {
              case "V2":
                {
                    util.windowEvents.show("V2");
                    break;
                }

              case "FULL":
                {
                    util.windowEvents.show("FULL");
                    break;
                }

              case "AnyWhereWorks":
                {
                    var chatWindow = util.caching.windows.getChat();
                    if (/win32/.test(process.platform) && chatWindow.isMinimized()) {
                        util.windowEvents.restore("Chat");
                        util.windowEvents.show("Chat");
                    } else {
                        util.windowEvents.show("Chat");
                    }
                    break;
                }

              default:
                {
                    console.log("Notification sender containerName in not avaialble. We are not taking action...!");
                    break;
                }
            }
        };
        FullNotification.prototype.sendClickEventToContainer = function(containerName, msg) {
            switch (containerName) {
              case "AnyWhereWorks":
                {
                    FULLClient.ipc.sendToChat(msg);
                    break;
                }

              case "FULL":
                {
                    FULLClient.ipc.sendToSB(msg);
                    break;
                }

              case "V2":
                {
                    FULLClient.ipc.sendToV2(msg);
                    break;
                }

              default:
                {
                    console.log("Default sequence excecuting in sendClickEventToContainer..!");
                    break;
                }
            }
        };
        FullNotification.prototype.handlefullexception = function(arg) {
            console.error("Exception in FullNotification module ::", arg);
            console.error("Error stack ::", arg.stack);
        };
        var notificationController = {
            activeNotification: null,
            terminalNotifierPath: "/node_modules/node-notifier/vendor/terminal-notifier.app/Contents/MacOS/terminal-notifier",
            permissionLevel: 511,
            applicationPath: util.escapeSpaces(process.execPath.replace(/([\/]Contents.*)/g, "")),
            canUseTerminlNotifier: false,
            create: function() {
                if (!this.activeNotification) {
                    this.activeNotification = true;
                    var args = [].slice.apply(arguments);
                    args.splice(0, 0, FullNotification);
                    new (FullNotification.bind.apply(FullNotification, args))();
                }
            },
            checkNotificationDependency: function() {
                if (/^darwin/.test(process.platform)) {
                    fs.access(FULLClient.getFilePath() + this.terminalNotifierPath, fs.W_OK && fs.R_OK && fs.X_OK, function(err, res) {
                        if (err) {
                            console.log("Error File down have permissions:", err);
                            this.givingPermissionToTerminalNotifier();
                        } else {
                            this.canUseTerminlNotifier = true;
                        }
                    }.bind(this));
                }
            },
            givingPermissionToTerminalNotifier: function() {
                fs.chmod(FULLClient.getFilePath() + this.terminalNotifierPath, this.permissionLevel, function(err, stdout, stdin) {
                    if (err) {
                        console.warn("Error in giving permission to terminal-notifier..!", err);
                        this.pushLogsToDev(err);
                    } else {
                        this.canUseTerminlNotifier = true;
                        console.warn("Given permission to terminal-notifier.app : ", this.canUseTerminlNotifier);
                    }
                }.bind(this));
            },
            pushLogsToDev: function(errLogs) {
                util.publish("/mailHelper/mailsend", {
                    type: "Error Log",
                    err: errLogs,
                    subject: "Notification error for " + userDAO.getEmail()
                }, function callback() {
                    console.warn("Error logs : ", errLogs);
                }.bind(this));
            }
        };
        R["FullNotification"] = FullNotification;
        R["notificationController"] = notificationController;
        var _n = Notification;
        R["Notification"] = function() {
            var args = Array.prototype.slice.call(arguments);
            var message = args[1];
            var n = new ClientListener("notify");
            n[n.opt].title = args[0];
            n[n.opt].body = message ? message.body : "";
            util.publish("/notification/create/show", n);
            return n;
        };
        util.subscribe("/notification/create/show", notificationController, notificationController.create);
        util.subscribe("/notification/create/checkNotificationDependency", notificationController, notificationController.checkNotificationDependency);
    } catch (e) {
        console.log("Exception in FullNotification ::", e);
        console.error("Exception stack ::", e.stack);
    }
})(this, jQuery, util);

(function(util) {
    var path = FULLClient.require("path");
    var fs = FULLClient.require("fs");
    var openBrowser = {
        externalUrl: null,
        macBrowser: null,
        extEvent: null,
        targetBrowser: {
            chrome: "Google Chrome",
            firefox: "Firefox.exe",
            iexplore: "IEXPLORE.exe"
        },
        availableBrowser: {},
        whiteList: [],
        setWhiteList: function(list) {
            if (list && list.length > 0) this.whiteList = list;
        },
        isInternal: function(url) {
            var arr = [ "formcreator", "-sb.appspot.com" ];
            for (var i = arr.length - 1; i >= 0 && arr[i]; i--) {
                var regex = new RegExp(arr[i], "g");
                if (regex.test(url)) {
                    util.loadURL(url);
                    return true;
                }
            }
            return this.isWhiteListed(url);
        },
        isWhiteListed: function(url) {
            var arr = this.whiteList;
            for (var i = arr.length - 1; i >= 0 && arr[i]; i--) {
                var regex = new RegExp(arr[i], "g");
                if (regex.test(url)) {
                    util.loadWebSiteInBrowser(url);
                    return true;
                }
            }
        },
        getBrowser: function() {
            var browserName = [ "chrome", "firefox", "iexplore" ];
            for (var i = 0; i < browserName.length; i++) {
                if (this.availableBrowser[browserName[i]]) return {
                    name: browserName[i],
                    path: this.availableBrowser[browserName[i]]
                };
            }
        },
        isURLValid: function(url) {
            return !/[,=]/.test(url);
        },
        checkLoaderTag: function(event) {
            if (this.isInternal(event.url)) return false;
            if (event.srcElement.id == "chat_webview") {
                util.loadWebSiteInBrowser(event.url);
                return;
            }
            if (event.url) {
                this.extEvent = event;
                this.externalUrl = event.url;
                this.startLoad();
            }
        },
        shorternUrl: function(url) {
            $.ajax({
                type: "POST",
                contentType: "application/json",
                url: "https://www.googleapis.com/urlshortener/v1/url?key=AIzaSyCq81yfRtt-CVaq8AUss9W1fibePVnZswg",
                data: JSON.stringify({
                    longUrl: url
                }),
                dataType: "json"
            }).done(function(res) {
                this.externalUrl = res.id;
                process.platform == "darwin" ? this.runMacCode() : this.runWinCode();
            }.bind(this)).fail(function() {
                this.runExistMethod();
            }.bind(this));
        },
        startLoad: function() {
            if (this.getPlatform() == "win32") this.runWinCode(); else this.runMacCode();
        },
        getChildProcess: function() {
            return require("child_process");
        },
        getPlatform: function() {
            return process.platform;
        },
        runWinCode: function() {
            if (this.isURLValid(this.externalUrl)) {
                this.triggerBat();
            } else this.shorternUrl(this.externalUrl);
        },
        triggerBat: function() {
            var url = this.externalUrl, browserInfoObj = this.getBrowser(), child = this.getChildProcess(), args, exeCMD;
            if (browserInfoObj) {
                switch (browserInfoObj.name) {
                  case "chrome":
                    {
                        args = '"' + browserInfoObj.path + '" -incognito ' + url;
                        break;
                    }

                  case "firefox":
                    {
                        args = '"' + browserInfoObj.path + '" -private-window ' + url;
                        break;
                    }

                  case "iexplore":
                    {
                        args = '"' + browserInfoObj.path + '" -private ' + url;
                        break;
                    }

                  default:
                    break;
                }
                exeCMD = 'start "browser" /b ' + args;
                console.log("Exec Command : ", exeCMD);
                child.exec(exeCMD, function(err, out) {
                    if (err) {
                        console.log("err :: ", err);
                        this.runExistMethod();
                    } else {
                        this.pushEventToAnalytics();
                    }
                }.bind(this));
                return true;
            }
            this.runExistMethod();
        },
        checkBrowserExists: function(browser, path) {
            fs.stat(path, function(err, stat) {
                if (!err) {
                    this.availableBrowser[browser] = path;
                }
            }.bind(this));
        },
        calculatePathFromRegKey: function(regString) {
            if (regString) {
                var regexM = regString.match(/[a-z](:)[^\n"]+/gim);
                if (regexM && regexM[0]) {
                    if (regexM[0].match(/chrome/i)) {
                        this.checkBrowserExists("chrome", regexM[0].trim());
                    } else if (regexM[0].match(/firefox/i)) {
                        this.checkBrowserExists("firefox", regexM[0].trim());
                    } else if (regexM[0].match(/iexplore/i)) {
                        this.checkBrowserExists("iexplore", regexM[0].trim());
                    }
                }
            }
        },
        getBrowserPathFromRegistry: function() {
            var child = this.getChildProcess(), browsers = Object.keys(this.targetBrowser);
            cmd1 = 'reg query "HKEY_LOCAL_MACHINE\\SOFTWARE\\Clients\\StartMenuInternet\\';
            cmd2 = '\\shell\\open\\command"';
            for (var i = 0; i < browsers.length; i++) {
                child.exec(cmd1 + this.targetBrowser[browsers[i]] + cmd2, function(err, res) {
                    if (!err) {
                        console.log(browsers[i], this.targetBrowser[browsers[i]], res);
                        this.calculatePathFromRegKey(res);
                    }
                }.bind(this));
            }
        },
        runMacCode: function() {
            if (!/[,=]/.test(this.externalUrl)) {
                var child = this.getChildProcess();
                var ChromeAppPath = "/Applications/Google\\ Chrome.app ";
                child.exec("cd " + ChromeAppPath, function(err, stdout) {
                    if (err) this.runExistMethod(); else {
                        this.macBrowser = "Chrome";
                        this.triggerBash();
                    }
                }.bind(this));
            } else this.shorternUrl(this.externalUrl);
        },
        triggerBash: function() {
            if (this.macBrowser) {
                var child = this.getChildProcess(), cmd = util.escapeSpaces(FULLClient.getFilePath() + "/scripts/privateBrowsing.sh");
                child.exec("sh " + cmd + " " + this.externalUrl + " " + this.macBrowser, function(err, stdout) {
                    if (!err) {
                        console.log("Error Free in triggerBash !!!!! :) ");
                        this.pushEventToAnalytics();
                    } else {
                        console.log("Error in triggering Bash script : ", err);
                        this.runExistMethod();
                    }
                }.bind(this));
            }
        },
        pushEventToAnalytics: function() {
            if (util.tabs.getActiveTab()) {
                var params = util.getParameters(util.tabs.getActiveTab().src);
                util.analytics.push(params["accountNumber"], analytics.INCOGNITO_LINK, params["connId"], util.tabs.getActiveTab().src);
            }
        },
        runExistMethod: function() {
            if (this.extEvent.url) {
                util.loadWebSiteInNewWindow(this.extEvent.url);
            }
        },
        init: function() {
            if (/^win/.test(process.platform)) {
                this.getBrowserPathFromRegistry();
            }
        }
    };
    util.subscribe("/open/browse/private/window", openBrowser, openBrowser.checkLoaderTag);
    util.subscribe("/open/browse/private/whitelist", openBrowser, openBrowser.setWhiteList);
    util.subscribe("module/controller/onload", openBrowser, openBrowser.init);
})(util);

(function(R, util) {
    var reLogin = {
        googleAppScript: "https://script.google.com/macros/s/AKfycbzHu2EQVazW4LQdns9i8KcHDwzX37_73cO_O7vldwwe-OCdlu95/exec?",
        wipeData: function() {
            this.removeUserFromSheet(userDAO.getEmail());
            userDAO.clear();
            this.reset();
            util.subscribe("/app/loginModule/onload/recieved", reLogin, reLogin.removeWebview);
        },
        reset: function() {
            util.publish("module/controller/reset");
            util.notification.create({
                title: "Application Cache",
                body: "Removed user data"
            });
            util.publish("/chat/quit/flag", true);
            util.publish("/util/v2/windows/caching/reset");
        },
        removeWebview: function() {
            $("webview:not(#LoginModule)").remove();
            util.publish("/msgModule/handler/", new ClientListener("badgelabel"));
            util.unsubscribe("/app/loginModule/onload/recieved", reLogin, reLogin.removeWebview);
            setTimeout(function() {
                console.log("Sending reLogin message to main ...");
                FULLClient.emitter.sendToMain({
                    eType: "reLogin",
                    name: "reLogin"
                });
            }, 0);
            util.publish("/util/window/events/show", namespace.CONTAINER_CHAT);
            if (/^win/.test(process.platform)) {
                util.publish("/util/window/events/restore", namespace.CONTAINER_CHAT);
            }
        },
        removeUserFromSheet: function(email) {
            if (email && util.isEmail(email)) {
                var url = this.googleAppScript + "userEmail=" + email + "&mode=" + FULLClient.getMode() + "&engine=" + process.versions["electron"] + "&remove=true";
                $.getJSON(url).done(function(infoJSON) {
                    if (infoJSON && /success/.test(infoJSON.status)) {
                        util.getCurrentWindow().webContents.session.flushStorageData(true);
                        setTimeout(function() {
                            util.app.restart();
                        }, 3e3);
                    }
                });
            }
        }
    };
    util.subscribe("/app/user/data/wipe", reLogin, reLogin.wipeData);
    util.subscribe("/app/remove/user/from/sheet", reLogin, reLogin.removeUserFromSheet);
    util.subscribe("/app/cookies/cleared", function() {
        reLogin.wipeData();
        util.clear.isCleared = false;
    });
    module.exports = reLogin;
})(window, util);

(function(R, util, lodash) {
    try {
        var remote = FULLClient.require("electron").remote;
        var dictionary = require("spellchecker");
        var Menu = remote.Menu;
        var noop = lodash.noop;
        var defaults = lodash.defaults;
        var isEmpty = lodash.isEmpty;
        var isFunction = lodash.isFunction;
        var isArray = lodash.isArray;
        var cloneDeep = lodash.clone;
        var source = null;
        var cEvent = null;
        var DEFAULT_NON_EDITABLE_TPL = [ {
            label: "Copy",
            click: executor.bind(null, "copy")
        }, {
            label: "Select All",
            click: executor.bind(null, "selectAll")
        } ];
        var DEFAULT_LINK_TPL = [ {
            label: "Open Link in New Tab",
            click: function() {
                var url = cEvent.linkURL;
                util.loadURL(url);
            }
        }, {
            label: "Open Link in Browser",
            click: function() {
                var url = cEvent.linkURL;
                util.loadWebSiteInBrowser(url);
            }
        }, {
            label: "Copy Link Address",
            click: function() {
                var url = cEvent.linkURL;
                util.copy(url);
            }
        }, {
            type: "separator"
        } ];
        var DEFAULT_SUGGESTIONS_TPL = [ {
            label: "No suggestions",
            click: noop
        }, {
            type: "separator"
        } ];
        var DEFAULT_EDITABLE_TPL = [ {
            label: "Undo",
            click: executor.bind(null, "undo")
        }, {
            type: "separator"
        }, {
            label: "Cut",
            click: executor.bind(null, "cut")
        }, {
            label: "Copy",
            click: executor.bind(null, "copy")
        }, {
            label: "Paste",
            click: executor.bind(null, "paste")
        }, {
            label: "Paste and Match Style",
            click: executor.bind(null, "pasteAndMatchStyle")
        }, {
            type: "separator"
        }, {
            label: "Select All",
            click: executor.bind(null, "selectAll")
        } ];
        function executor(action) {
            var args = Array.prototype.slice.call(arguments, 1);
            if (source && action) {
                source[action].apply(null, args);
                cEvent = source = null;
            }
        }
        var contextMenu = {
            setSource: function(src) {
                if (src) {
                    return source = src;
                }
            },
            setContextEventObj: function(cEve) {
                if (cEve) {
                    return cEvent = cEve;
                }
            },
            getSelection: function(cEve) {
                if (cEve && cEve.misspelledWord) {
                    return {
                        isMisspelled: true,
                        spellingSuggestions: getSuggestions(cEve.misspelledWord)
                    };
                }
            },
            getSuggestions: function(word) {
                if (word && (word = word.toLowerCase())) {
                    return dictionary.getCorrectionsForMisspelling(word).slice(0, 5);
                }
            },
            addContentEditable: function(mainTMP) {
                if (/^win/.test(process.platform)) DEFAULT_EDITABLE_TPL.splice(6, 1);
                mainTMP.push.apply(mainTMP, DEFAULT_EDITABLE_TPL);
                return mainTMP;
            },
            addSuggestions: function(mainTMP, word) {
                var suggestions = this.getSuggestions(word);
                console.log("suggestions we got for word[" + word + "] : ", suggestions);
                if (!suggestions.length) {
                    mainTMP.unshift.apply(mainTMP, DEFAULT_SUGGESTIONS_TPL);
                    return mainTMP;
                }
                mainTMP.unshift.apply(mainTMP, suggestions.map(function(suggestion) {
                    return {
                        label: suggestion,
                        click: executor.bind(null, "replaceMisspelling", suggestion)
                    };
                }).concat({
                    type: "separator"
                }));
                return mainTMP;
            },
            addLinkOptions: function(mainTMP, url) {
                mainTMP.push.apply(mainTMP, DEFAULT_LINK_TPL);
                return mainTMP;
            },
            getTemplate: function(contextEvObj) {
                var template = [];
                if (contextEvObj.isEditable) {
                    if (contextEvObj.misspelledWord) {
                        this.addSuggestions(template, contextEvObj.misspelledWord);
                    }
                    this.addContentEditable(template);
                } else if (contextEvObj.linkURL) {
                    this.addLinkOptions(template);
                    template.push.apply(template, DEFAULT_NON_EDITABLE_TPL);
                } else {
                    template.push.apply(template, DEFAULT_NON_EDITABLE_TPL);
                }
                return template;
            },
            build: function(template) {
                if (template) return Menu.buildFromTemplate(template);
            },
            run: function(menu) {
                if (menu) {
                    menu.popup(remote.getCurrentWindow());
                    return true;
                }
            }
        };
        util.subscribe("/context/menu/event/", function(srcEvent, contextEvent) {
            contextMenu.setSource(srcEvent.sender);
            contextMenu.setContextEventObj(contextEvent);
            var template = contextMenu.getTemplate(cEvent);
            var menu = contextMenu.build(template);
            contextMenu.run(menu);
        });
        module.exports = contextMenu;
    } catch (e) {
        console.log("Error in context-menu impl ", e.message);
        console.log("Error in context-menu impl ", e.stack);
    }
})(this, util, _);

(function(R, M) {
    var fs = require("fs");
    var child = require("child_process").exec;
    var writePermissionChecker = {
        dom: {
            updateFailedPopup: $("#updateFailedPopup"),
            close: $("#updateFailedPopup").find(".btnLightblue"),
            background: $(".transparentBg")
        },
        _canStart: function() {
            return userDAO.getSkillByName("FullWork") && util.window.getName() == "AnyWhereWorks" || !userDAO.getSkillByName("FullWork") && util.window.getName() == "FULL";
        },
        checkUserWritePermissionAndStart: function(permissionCB) {
            if (!this._canStart()) return false;
            if (/darwin/.test(process.platform)) {
                fs.access(FULLClient.getFilePath(), fs.W_OK, function(err, stdin, stdout) {
                    if (err) {
                        console.log("User dont have permission to Install files. Please Contact IT.!", err);
                        this.showPermissionDeniedPopUp();
                        permissionCB.call(this, false);
                    } else {
                        console.log("User have Permission to write file, going forward with engine Updation.");
                        permissionCB.call(this, true);
                    }
                }.bind(this));
            } else {
                child("cls -oq", function(err) {
                    if (err) {
                        console.warn("Error:::", err);
                        console.log("User dont have permission to Install files. Please Contact IT.!", err);
                        this.showPermissionDeniedPopUp();
                        permissionCB.call(this, false);
                    } else {
                        permissionCB.call(this, true);
                    }
                });
            }
        },
        cachePopupDom: function() {
            this.addListernerForPermissionPopUpButton();
        },
        hidePopUp: function() {
            this.dom.updateFailedPopup.hide();
        },
        showPopUp: function() {
            this.dom.updateFailedPopup.show();
        },
        showBackground: function() {
            this.dom.background.show();
        },
        hideBackground: function() {
            this.dom.background.hide();
        },
        addListernerForPermissionPopUpButton: function() {
            if (this.dom.updateFailedPopup && this.dom.close) {
                this.dom.close.click(function() {
                    console.log("User closing Permission Popup..!");
                    this.hideBackground();
                    this.hidePopUp();
                }.bind(this));
            }
        },
        showPermissionDeniedPopUp: function() {
            this.showBackground();
            this.showPopUp();
        },
        hidePermissionDeniedPopUp: function() {
            this.hideBackground();
            this.hidePopUp();
        }
    };
    module.exports = writePermissionChecker;
    R["writePermissionChecker"] = writePermissionChecker;
    M.subscribe("/start/checkUserWritePermissionAndStart/", writePermissionChecker, writePermissionChecker.checkUserWritePermissionAndStart);
    M.subscribe("module/controller/onload", writePermissionChecker, writePermissionChecker.cachePopupDom);
})(this, util);

(function(R, util) {
    var fs = FULLClient.require("fs");
    var path = FULLClient.require("path");
    var engineUpdater = {
        infoJson: null,
        userPermission: false,
        periodicCheck: null,
        engineVersion: process.versions["electron"],
        googleAppScript: "https://script.google.com/macros/s/AKfycbzHu2EQVazW4LQdns9i8KcHDwzX37_73cO_O7vldwwe-OCdlu95/exec?",
        _canStart: function() {
            return userDAO.getSkillByName("FullWork") && util.window.getName() == "AnyWhereWorks" || !userDAO.getSkillByName("FullWork") && util.window.getName() == "FULL";
        },
        getTempDirectory: function() {
            return util.getTempDirectory();
        },
        getConfigInfoFromTemp: function() {
            try {
                return require(path.join(this.getTempDirectory(), "appMode.json"));
            } catch (err) {
                return false;
            }
        },
        writeIntoTemp: function(appPath, infoJSON) {
            var appMode;
            if (infoJSON && FULLClient.isModeValid(infoJSON.modetoswitch)) appMode = infoJSON.modetoswitch; else appMode = FULLClient.getMode();
            var data = JSON.stringify({
                appMode: appMode
            });
            fs.writeFile(path.join(this.getTempDirectory(), "appMode.json"), data, function(err) {
                if (err) {
                    console.warn("Error in Writing appMode in Engine Updation");
                }
                if (process.platform == "darwin") this.replaceMacApp(appPath, infoJSON.downloadUrl.mac.filename); else if (process.platform == "win32") this.replaceWinApp(appPath, infoJSON.downloadUrl.win.filename);
            }.bind(this));
        },
        deleteTmpConfig: function(config) {
            if (config) {
                console.warn("Mode switch is available  : " + config.appMode);
                tmpPath = path.join(this.getTempDirectory(), "appMode.json");
                fs.unlink(tmpPath, function(err) {
                    if (err) console.log("Error in deleting appMode tmpPath : ");
                    FULLClient.setMode(config.appMode);
                });
                return true;
            }
            throw new Error("Invalid param : " + typeof config);
        },
        checkForUserAccess: function(json) {
            if (json && json.wipe) {
                console.log("User dont have access use application, wiping data :", json);
                FULLClient.ipc.sendToSB({
                    name: "analytics",
                    accountNumber: null,
                    eventAction: analytics.WIPE_DATA,
                    connId: FULLClient.getMode() + " " + FULLClient.getManifest().version + " " + process.platform,
                    metaInfo: "Wiping data for user using spreadsheet."
                });
                util.publish("/remove/access/data/");
                return true;
            }
        },
        popUpDownloadUI: function() {
            if (this._canStart() && this.infoJson && this.infoJson.status == "success") {
                console.log("Showing UI for engineUpdate", this.infoJson);
                util.publish("updateUI/ShowUI/container", "engineUpdate", this.infoJson, this.downloadAndInstall, this);
            }
        },
        isGuestUpdateAvailable: function() {
            var guestInfo = util.storage.get("guestUpdate");
            if (guestInfo && Object.keys(guestInfo).length) {
                return true;
            }
        },
        start: function(isPeriodicCheck) {
            if (compareVersions(process.versions.electron, "1.3.13") == -1) {
                console.warn("============== patching to ============== 1.3.13");
                this.patch();
                return;
            }
            if (!this._canStart()) return false;
            if (this.isGuestUpdateAvailable() && !isPeriodicCheck) return false;
            $.getJSON(this.googleAppScript + "userEmail=" + userDAO.getEmail() + "&mode=" + FULLClient.getMode() + "&engine=" + process.versions["electron"]).done(function(infoJSON) {
                this.infoJson = infoJSON ? infoJSON : null;
                if (this.checkForUserAccess(infoJSON)) return;
                var tmpConfig = this.getConfigInfoFromTemp();
                if (FULLClient.getMode() != "code") {
                    console.log("Engine Updater response : ", infoJSON);
                    if (infoJSON.version && infoJSON.version.trim() && !/[^0-9.]/.test(infoJSON.version) && this.engineVersion != infoJSON.version && infoJSON.status == "success") {
                        this.popUpDownloadUI();
                    } else if (infoJSON.modetoswitch && FULLClient.isModeValid(infoJSON.modetoswitch) && FULLClient.getMode() != infoJSON.modetoswitch) {
                        FULLClient.setMode(infoJSON.modetoswitch);
                    } else if (tmpConfig) {
                        this.deleteTmpConfig(tmpConfig);
                        console.warn("Removed appMode key from localStorage");
                    } else {
                        console.warn("Commencing ASAR updater.");
                        util.publish("/asar/update/commence");
                    }
                }
            }.bind(this));
        },
        patch: function() {
            var infoJSON = this.infoJson = {
                mode: "1.x",
                version: "1.3.13",
                name: "EngineUpdater",
                downloadUrl: {
                    mac: {
                        url: "http://images.sb.a-cti.com/TC/electron/live/engine/app-mac-1.3.13.zip",
                        filename: "AnywhereWorks.app"
                    },
                    win: {
                        url: "http://images.sb.a-cti.com/TC/electron/live/engine/app-win-1.3.13.zip",
                        filename: "app-win-1.3.13.exe"
                    }
                },
                status: "success",
                wipe: false,
                modetoswitch: false
            };
            if (this.checkForUserAccess(this.infoJson)) return;
            var tmpConfig = this.getConfigInfoFromTemp();
            if (FULLClient.getMode() != "code") {
                console.log("Engine Updater response : ", infoJSON);
                if (infoJSON.version && infoJSON.version.trim() && !/[^0-9.]/.test(infoJSON.version) && this.engineVersion != infoJSON.version && infoJSON.status == "success") {
                    this.popUpDownloadUI();
                } else if (infoJSON.modetoswitch && FULLClient.isModeValid(infoJSON.modetoswitch) && FULLClient.getMode() != infoJSON.modetoswitch) {
                    FULLClient.setMode(infoJSON.modetoswitch);
                } else if (tmpConfig) {
                    this.deleteTmpConfig(tmpConfig);
                    console.warn("Removed appMode key from localStorage");
                } else if (!isPeriodicCheck) {
                    console.warn("Commencing ASAR updater.");
                    util.publish("/asar/update/commence");
                }
            }
        },
        downloadAndInstall: function() {
            var infoJSON = arguments[0];
            var UpdationTrigger = arguments[1];
            if (UpdationTrigger && infoJSON) {
                console.debug("Starting download process.. ");
                this.downloadZip(infoJSON, function(extractUrl) {
                    this.extractZip(extractUrl, function(appPath) {
                        this.writeIntoTemp(appPath, infoJSON);
                    }.bind(this));
                }.bind(this));
            }
        },
        downloadZip: function(response, cb) {
            var path = require("path"), downloadPercentage = 0, previousPercentage, currentPercentage, file, temp = util.getTempDirectory();
            temp = path.resolve(temp + "/EngineUpdates.zip");
            var downloadZipUrl = this.getDownloadZipUrl(response);
            downloadZipUrl = downloadZipUrl.replace(/(http:\/\/images.sb.a-cti.com)/, "https://storage.googleapis.com/images.sb.a-cti.com");
            http = util.isHttps(downloadZipUrl) ? require("https") : require("http");
            console.log("URL Path engine being downloaded :", downloadZipUrl);
            var req = http.get(downloadZipUrl, function(res) {
                if (res.statusCode == 200) {
                    util.publish("updateUI/hideDownloadWinandshowProgress");
                    var len = parseInt(res.headers["content-length"], 10);
                    var total = len / 1e6;
                    if (res.headers["content-type"] == "application/zip" || res.headers["content-type"] == "application/x-zip-compressed") {
                        file = fs.createWriteStream(temp);
                        res.on("data", function(chunk) {
                            downloadPercentage += chunk.length;
                            currentPercentage = Math.floor(downloadPercentage / res.headers["content-length"] * 100);
                            if (previousPercentage != currentPercentage) {
                                previousPercentage = currentPercentage;
                                util.publish("progressUI/updatePercentage", previousPercentage);
                            }
                        }.bind(this));
                        res.pipe(file);
                        res.resume();
                        res.on("end", function end() {
                            cb(temp);
                        });
                    } else {
                        util.publish("updateUI/hidePopUp");
                    }
                } else {
                    util.publish("updateUI/hidePopUp");
                }
            }.bind(this));
            req.on("error", function(err) {
                console.log("Error in downloading file::", err);
            }.bind(this));
        },
        extractZip: function(src, cb) {
            var child_process = this.createChildProcess(), path = require("path"), unzipChildProcessCmd, dest;
            if (process.platform == "darwin") {
                dest = util.getTempDirectory() + "EngineUpdates";
                unzipChildProcessCmd = 'unzip -oq "' + src + '" -d "' + dest + '" ';
            } else if (process.platform == "win32") {
                dest = path.resolve(process.env.TEMP + "/EngineUpdates");
                unzipChildProcessCmd = ' "' + path.resolve(FULLClient.getFilePath(), "tools/unzip.exe") + '" -o "' + src + '" -d "' + dest + '" ';
            }
            console.log("Path : " + unzipChildProcessCmd);
            child_process.exec(unzipChildProcessCmd, function(err) {
                if (!err) cb(dest); else {
                    console.log("Error in Extracting a file using child process : " + err);
                }
            });
        },
        createChildProcess: function() {
            return require("child_process");
        },
        replaceMacApp: function(dest, filename) {
            console.log("What is this :: " + dest);
            var appNameToQuit = util.escapeSpaces(FULLClient.getAppName());
            var sourcePath = util.escapeSpaces(path.join(dest, filename));
            var destionationPath = util.escapeSpaces(path.join("/Applications", filename));
            var currentAppPath = util.escapeSpaces(process.execPath.replace(/([\/]Contents.*)/g, ""));
            var shellScriptPath = util.escapeSpaces(path.join(FULLClient.getFilePath(), "scripts", "engine.sh"));
            var script = "sh " + " " + shellScriptPath + " " + appNameToQuit + " " + sourcePath + " " + destionationPath + " " + currentAppPath;
            console.log("script Details : " + script);
            var child = this.createChildProcess();
            child.exec(script, function(err) {
                if (err) console.log("Error in child_process : " + err);
            });
        },
        replaceWinApp: function(dest, filename) {
            var child_process = this.createChildProcess();
            var execPath = path.join(process.env.TEMP, "EngineUpdates", filename);
            console.log("Path : " + execPath);
            child_process.exec('"' + execPath + '"', function(err) {
                if (err) {
                    util.publish("updateUI/hidePopUp");
                    console.log("User denied permission or failed to execute the update.exe : ", err);
                }
            });
        },
        getDownloadZipUrl: function(response) {
            if (process.platform == "darwin") return response.downloadUrl.mac.url; else return response.downloadUrl.win.url;
        },
        checkUserWritePermissionAndStart: function(periodicCheck) {
            this.periodicCheck = periodicCheck ? periodicCheck : false;
            util.publish("/start/checkUserWritePermissionAndStart/", this.permissionCallback);
        },
        permissionCallback: function(permission) {
            if (permission) {
                engineUpdater.userPermission = permission;
                engineUpdater.periodicCheck ? engineUpdater.start(true) : engineUpdater.start();
            } else {
                console.log("User dont have permission :", permission);
                engineUpdater.userPermission = permission;
            }
        }
    };
    R["engineUpdater"] = engineUpdater;
    module.exports = engineUpdater;
    setInterval(function() {
        engineUpdater.checkUserWritePermissionAndStart(true);
    }, FULLClient.getMode() == "test-1.x" ? 6e4 : 3e5);
    util.subscribe("/start/engine/updater/", engineUpdater, engineUpdater.checkUserWritePermissionAndStart);
})(this, util);

(function(R, mediator) {
    function hideCancelButtons() {
        $(".btnDarkblue").hide();
        $(".closeAct").hide();
    }
    hideCancelButtons();
    function showCancelButtons() {
        $(".btnDarkblue").show();
        $(".closeAct").show();
    }
    function checkButtons() {
        var v2Obj = util.storage.get("v2");
        if (v2Obj && v2Obj.lastReceivedStatus && new RegExp(v2Obj.lastReceivedStatus, "ig").test([ "ActiveResponse", "Active Response", "Default", "Busy", "Repeat", "Chat", "PendingBusy", "CallingCustomer", "Video Call" ])) {
            showCancelButtons();
        } else hideCancelButtons();
    }
    var popUpVersion = {
        headingVersion: $(".updateRt").find("h1"),
        isAlpha: function(version) {
            return /[a-z]/i.test(version);
        },
        isValidTagVersion: function(version) {
            if (version && !this.isAlpha(version)) return version;
        },
        show: function(version) {
            if (version) {
                return $(".updateLf").find("p:eq(1)").text("v" + version);
            }
        },
        hide: function() {
            return $(".updateLf").find("p:eq(1)").text("");
        },
        getHeadingText: function() {
            return "What's new in this update?";
        },
        changeHeadingVersion: function(version) {
            var headingTxt;
            if (version) headingTxt = "What's new in v" + version + "?"; else headingTxt = this.getHeadingText();
            return this.headingVersion.text(headingTxt);
        },
        update: function(version) {
            if (version && this.isValidTagVersion(version)) {
                this.changeHeadingVersion(version);
                this.show(version);
            } else {
                this.changeHeadingVersion();
                this.hide();
            }
        }
    };
    var popUpText = {
        gitAccessToken: "e18284d04c7da26a960909d4f0ff9632f749c3f2",
        defaultMsg: "<p>AnyWhereWorks have some Updates, Restart to apply the changes.</p>",
        marked: null,
        releaseDetails: $(".updateRt").find("div"),
        makeLinkFunctional: function() {
            if (this.addTargetToLinks()) this.setListenersToLinks();
        },
        addTargetToLinks: function() {
            var links = this.getLinks();
            if (links && links.length) return links.attr("target", "_blank");
        },
        getLinks: function() {
            return $(".updateRt").find("div").find("a");
        },
        setListenersToLinks: function() {
            util.getCurrentWindow().webContents.on("new-window", function(event, urlToOpen) {
                event.preventDefault();
                util.loadWebSiteInBrowser(urlToOpen);
            });
        },
        init_markDown_module: function() {
            this.marked = FULLClient.require("marked");
            this.marked.setOptions({
                gfm: true,
                breaks: true
            });
            return this.marked;
        },
        update: function(updateType, metaInfo) {
            this.fetchDetailsAndUpdateInUI(updateType, metaInfo, this.updateDetailsAndShowUI, this);
        },
        updateErrorHandler: function(updateType, metaInfo, isPeriodicCheck) {
            if (updateUI.isContainerUpdate(updateType)) {
                this.attachDefaultMsg();
                this.showPopUp(metaInfo, updateType);
            } else {
                console.warn("1. Lock released for getting new updates");
                updateUI.setProgressFlag(false);
                updateUI.releaseActiveUpdate();
                console.warn("2. Cleared guest update localStorage info.");
                guestPage.clearInfo();
                console.warn("3. Starting Engine updater");
                util.publish("/start/engine/updater/", isPeriodicCheck);
            }
        },
        showPopUp: function(metaInfo, updateType) {
            checkButtons();
            updateUI.show.call(updateUI, metaInfo, updateType);
            updateUI.focusWindow();
        },
        updateDetailsAndShowUI: function(updateType, metaInfo, tagInfo) {
            var releaseMsg = tagInfo.body;
            if (releaseMsg) {
                this.formatAndAppendText(releaseMsg);
                this.showPopUp(metaInfo, updateType);
            } else {
                this.updateErrorHandler(updateType, metaInfo, true);
            }
        },
        getVersionByUpdate: function(version, updateType) {
            if (version && updateType) {
                if (updateType == "appUpdate") return version = "v" + version; else if (updateType == "engineUpdate") return version = "engineV" + version; else return version;
            }
        },
        getReqUrl: function(metaInfo) {
            if (metaInfo && metaInfo.updateVersion) {
                var repo, tag_name;
                if (metaInfo.gitRepoName) repo = metaInfo.gitRepoName; else repo = "FULLClient-Electron";
                return "https://api.github.com/repos/Adaptavant/" + repo + "/releases/tags/" + metaInfo.updateVersion + "?access_token=" + this.gitAccessToken;
            }
        },
        fetchDetailsAndUpdateInUI: function(updateType, metaInfo, callBack, context) {
            if (updateType && metaInfo && callBack) {
                metaInfo.updateVersion = this.getVersionByUpdate(metaInfo.version, updateType);
                console.debug("update version in meta info ", metaInfo.updateVersion);
                console.debug("git url :", this.getReqUrl(metaInfo));
                return this.getReleaseText(this.getReqUrl(metaInfo)).done(function successCB(tagInfo) {
                    console.log("successCB in fetch details : ", tagInfo);
                    if (callBack) callBack.call(context || null, updateType, metaInfo, tagInfo);
                }.bind(this)).fail(function failCB(r) {
                    console.log("Error in Fetching ReleaseDetails :", r);
                    this.updateErrorHandler(updateType, metaInfo, true);
                }.bind(this));
            }
        },
        getReleaseText: function(gitReleaseUrl) {
            if (gitReleaseUrl) {
                return $.ajax({
                    url: gitReleaseUrl,
                    type: "GET",
                    dataType: "json",
                    processData: false,
                    contentType: false
                });
            }
            throw new Error("git ReleasesUrl Not found" + gitReleaseUrl);
        },
        attachDefaultMsg: function() {
            this.attach(this.defaultMsg);
        },
        formatToMarkDown: function(releaseText) {
            if (releaseText) {
                var result = this.marked(releaseText);
                return result;
            }
        },
        formatAndAppendText: function(releaseText) {
            if (releaseText) {
                this.attach(this.formatToMarkDown(releaseText));
                this.makeLinkFunctional();
            }
        },
        attach: function(formattedTxt) {
            if (formattedTxt) {
                this.clear();
                this.releaseDetails.append(formattedTxt);
            }
        },
        clear: function() {
            return this.releaseDetails.text("");
        }
    };
    popUpText.init_markDown_module();
    var updateUI = {
        updateInProgress: false,
        updatePanel: $(".updatePanel"),
        xClose: $(".updatePanel").find("code"),
        downloadBtn: $(".updatePanel").find(".btnGreen"),
        closeBtn: $(".updatePanel").find(".btnDarkblue"),
        updateFailPanel: $(".updateFailedPopup"),
        transparentBg: $("#transparentBg"),
        activeUpdate: null,
        cbDfd: null,
        cbInfo: {
            cb: null,
            context: null,
            metaInfo: null,
            uType: null
        },
        clearDfd: function() {
            this.cbDfd = null;
        },
        clearCbInfo: function() {
            this.cbInfo = {};
        },
        cacheCbInfo: function(updateType, metaInfo, cb, cbContext) {
            if (this.isValidCB(cb)) {
                this.cbInfo["cb"] = cb;
                if (updateType) this.cbInfo["uType"] = updateType;
                this.cbInfo["info"] = metaInfo;
                this.cbInfo["context"] = cbContext;
            } else {
                this.clearCbInfo();
            }
        },
        isValidCB: function(callBack) {
            if (callBack && typeof callBack == "function") {
                return true;
            }
        },
        show: function(metaInfo, updateType) {
            this.updatePanel.focus();
            this.setActiveUpdate(updateType);
            this.transparentBg.show();
            if (this.isGuestUpdate(updateType) && metaInfo.cancelBtnName && /close/i.test(metaInfo.cancelBtnName)) {
                this.downloadBtn.hide();
            } else {
                this.downloadBtn.show();
            }
            this.updatePanel.show();
        },
        hide: function(updateStillActive) {
            if (!updateStillActive) this.releaseActiveUpdate();
            this.transparentBg.hide();
            this.updatePanel.hide();
        },
        focusWindowOnUpdateCheck: function() {
            if (util.checkForUpdates.isFromMenu()) {
                this.focusWindow();
            }
        },
        showFailPopuUp: function() {
            this.updateFailPanel.show();
        },
        hideFailPopuUp: function() {
            this.updateFailPanel.hide();
        },
        hideDownloadWinandshowProgress: function() {
            this.hide(true);
            progressUI.show();
        },
        manualClearCache: function() {
            this.hide();
            progressUI.hide();
        },
        renameDownloadBtn: function(btnName) {
            if (btnName) this.downloadBtn.text(btnName); else this.downloadBtn.text("Restart");
        },
        renameCancelBtn: function(btnName) {
            if (btnName) this.closeBtn.text(btnName); else this.closeBtn.text("Later");
        },
        isContainerUpdate: function(updateType) {
            if (updateType && updateType == "appUpdate" || updateType == "engineUpdate") return true;
        },
        isGuestUpdate: function(updateType) {
            if (updateType && /guest/.test(updateType)) return true;
        },
        updatePopUpInfo: function(updateType, metaInfo) {
            if (this.isContainerUpdate(updateType)) {
                this.renameDownloadBtn("Update");
            } else {
                this.renameDownloadBtn(metaInfo.restartBtnName);
                this.renameCancelBtn(metaInfo.cancelBtnName);
            }
            popUpText.update(updateType, metaInfo);
            popUpVersion.update(metaInfo.version);
        },
        focusWindow: function() {
            util.getCurrentWindow().show();
            util.getCurrentWindow().focus();
        },
        isOtherUpdateActive: function() {
            if (updateUI.activeUpdate) return true;
        },
        setActiveUpdate: function(updateType) {
            if (updateType) this.activeUpdate = updateType;
        },
        releaseActiveUpdate: function() {
            this.activeUpdate = null;
        },
        isValidVersion: function(version) {
            if (/[0-9]/i.test(version)) {
                var arr = version.split(".");
                var len = arr.length;
                if (arr && len && len == 3) {
                    for (var i = 0; i < len; i++) {
                        var num = parseInt(arr[i]);
                        if (isNaN(num)) return false; else {
                            if (i == len - 1) return true;
                        }
                    }
                } else return false;
            } else return false;
        },
        validateVersionForContainer: function(updateType, metaInfo) {
            if (this.isContainerUpdate(updateType)) {
                if (metaInfo.version && this.isValidVersion(metaInfo.version)) {
                    return true;
                } else return false;
            } else return true;
        },
        cacheCBAndShowUI: function(updateType, metaInfo, cb, context) {
            this.setActiveUpdate(updateType);
            this.cacheCbInfo(updateType, metaInfo, cb, context);
            this.updatePopUpInfo(updateType, metaInfo);
        },
        showUpdateInfo: function(updateType, metaInfo, cb, context) {
            if (this.validateVersionForContainer(updateType, metaInfo)) {
                if (!this.isOtherUpdateActive()) {
                    console.log("********* other update not active ********* so proceed ", updateType);
                    this.cacheCBAndShowUI(updateType, metaInfo, cb, context);
                } else {
                    console.log("!!!!!! other update is active !!!!! ,so cancel ", updateType);
                    this.focusWindowOnUpdateCheck();
                    if (this.isGuestUpdate(updateType)) {
                        guestPage.cancelUpdate(metaInfo);
                    }
                }
            }
        },
        showGuestUpdateInfo: function(metaInfo, onLoadClosBtnCB, context) {
            var guestInfo = metaInfo;
            guestInfo.cancelBtnName = "Close";
            this.cacheCBAndShowUI("guest", guestInfo, onLoadClosBtnCB, context);
        },
        setProgressFlag: function(bool) {
            this.updateInProgress = bool;
        },
        isUpdateInProgress: function() {
            return this.updateInProgress;
        },
        commenceUpdate: function() {
            if (!this.isUpdateInProgress()) {
                this.setProgressFlag(true);
                util.checkForUpdates.setFlag(false);
                if (this.cbInfo["cb"]) {
                    this.cbInfo["cb"].apply(this.cbInfo["context"] || this, [ this.cbInfo["info"], true ]);
                    this.clearCbInfo();
                } else {
                    this.setProgressFlag(false);
                    console.warn("Callback is not provided for commencing Update..", this.cbInfo["cb"]);
                }
            }
        },
        cancelUpdate: function() {
            util.checkForUpdates.setFlag(false);
            this.hide();
            if (this.cbInfo["uType"] && this.isGuestUpdate(this.cbInfo["uType"]) && this.cbInfo["cb"]) {
                this.cbInfo["cb"].apply(this.cbInfo["context"] || this, [ this.cbInfo["info"], false ]);
            }
        },
        sendMessageToMain: function(obj) {
            if (FULLClient && obj) {
                FULLClient.ipc.sendToSB(obj);
            }
        },
        setListenersOnLoad: function() {
            if (this.updatePanel) {
                console.log("setting Listeners OnLoad ..");
                if (this.downloadBtn) {
                    this.downloadBtn.click(function() {
                        this.sendMessageToMain({
                            name: "analytics",
                            accountNumber: null,
                            eventAction: analytics.UPDATE_BTN_CLICKED,
                            connId: FULLClient.getMode() + " " + FULLClient.getManifest().version + " " + process.platform,
                            metaInfo: "User clicking download btn in updater"
                        });
                        this.commenceUpdate();
                    }.bind(this));
                }
                if (this.closeBtn) {
                    this.closeBtn.click(function() {
                        this.sendMessageToMain({
                            name: "analytics",
                            accountNumber: null,
                            eventAction: analytics.UPDATE_LATER_CLICKED,
                            connId: FULLClient.getMode() + " " + FULLClient.getManifest().version + " " + process.platform,
                            metaInfo: "User clicking download Later btn in updater"
                        });
                        this.cancelUpdate();
                    }.bind(this));
                }
                if (this.xClose) {
                    this.xClose.click(function() {
                        this.cancelUpdate();
                    }.bind(this));
                }
            }
            guestPage.onModuleLoad();
        }
    };
    mediator.subscribe("module/controller/onload", updateUI, updateUI.setListenersOnLoad);
    mediator.subscribe("updateUI/cancelUpdate", updateUI, updateUI.cancelUpdate);
    mediator.subscribe("updateUI/ShowUI/container", updateUI, updateUI.showUpdateInfo);
    mediator.subscribe("updateUI/hideDownloadWinandshowProgress", updateUI, updateUI.hideDownloadWinandshowProgress);
    mediator.subscribe("/app/loginModule/onload/recieved", updateUI, updateUI.manualClearCache);
    var progressUI = {
        processPanel: $(".updating"),
        percentage: $(".updating").find("p"),
        progbarBelow50: $(".updating").find(".circle_bar.below50.updatedSuccess1"),
        progbarAbove50: $(".updating").find(".circle_bar.above50.updatedSuccess1"),
        below50css: "linear-gradient(90deg, #cccccc 50%, rgba(0, 0, 0, 0) 50%, rgba(0, 0, 0, 0)), linear-gradient(91deg, #00cd93 50%, #cccccc 50%, #cccccc)",
        above50css: "linear-gradient(-90deg, #00cd93 50%, rgba(0, 0, 0, 0) 50%, rgba(0, 0, 0, 0)), linear-gradient(270deg, #00cd93 50%, #cccccc 50%, #cccccc)",
        show: function() {
            updateUI.transparentBg.show();
            this.processPanel.show();
        },
        hide: function() {
            updateUI.transparentBg.hide();
            this.processPanel.hide();
        },
        circlebarUI: function(percent) {
            if (percent < 50) {
                var degree = Math.floor(3.6 * percent);
                return this.progbarBelow50.css("background-image", this.below50css.replace(/91/, 90 + degree))[0];
            } else {
                this.progbarBelow50.hide();
                this.progbarAbove50.show();
                var degree = Math.floor(3.6 * (percent - 50));
                return this.progbarAbove50.css("background-image", this.above50css.replace(/-90/, -90 + degree))[0];
            }
        },
        updatePercentage: function(percent) {
            this.circlebarUI(percent);
            this.percentage.text(percent + "% - Completed ...");
        }
    };
    mediator.subscribe("progressUI/updatePercentage", progressUI, progressUI.updatePercentage);
    mediator.subscribe("progressUI/showProgress", progressUI, progressUI.show);
    mediator.subscribe("progressUI/hideProgress", progressUI, progressUI.hide);
    var guestPage = {
        checkForUpdates: false,
        setFlag: function(bool) {
            this.checkForUpdates = bool;
        },
        getViewByUrl: function(lUrl) {
            if (lUrl) {
                var wv = $("webview");
                for (var i = wv.length - 1; i >= 0; i--) {
                    if (wv[i].src.trim() == lUrl.trim() || wv[i].src.trim().includes(lUrl.trim())) {
                        return wv[i];
                    }
                }
            }
        },
        getBtnClickOption: function(restartBtn) {
            if (restartBtn) return "restartBtnClick"; else return "cancelBtnClick";
        },
        reloadChatWebview: function(view) {
            if (view) {
                view.reloadIgnoringCache();
            }
        },
        commenceUpdate: function(view) {
            console.warn("reloading guest page...");
            updateUI.setProgressFlag(false);
            this.clearInfo();
            updateUI.hide();
            this.reloadChatWebview(view);
        },
        cancelUpdate: function(metaInfo) {
            this.storeInfo(metaInfo);
            setTimeout(function() {
                console.debug("calling guest update with metaInfo :after one hour", metaInfo);
                this.showUpdateDetailsWithRestart(metaInfo);
            }.bind(this), FULLClient.getMode() == "test" ? 2e4 : 36e5);
        },
        postMessageToGuestPage: function(metaInfo, btnClkBoolean, isForce) {
            var view = this.getViewByUrl(metaInfo.domain);
            if (view) {
                var infoObj = new ClientListener(this.getBtnClickOption(btnClkBoolean));
                console.log("Posting message to guest as :", infoObj);
                util.webview.post(view, infoObj);
                if (!isForce) {
                    if (btnClkBoolean) {
                        this.commenceUpdate(view);
                        this.setFlag(false);
                    } else {
                        this.cancelUpdate(metaInfo);
                        if (this.checkForUpdates) {
                            this.setFlag(false);
                            util.publish("/start/engine/updater/");
                        } else {
                            util.publish("/start/engine/updater/", true);
                        }
                    }
                }
            }
        },
        isValidMsg: function(msg) {
            if (msg && msg.version && msg.gitRepoName) {
                return true;
            }
        },
        isEmptyObj: function(obj) {
            return Object.keys(obj).length === 0;
        },
        retrieveInfo: function() {
            var guestInfo = util.storage.get("guestUpdate");
            if (guestInfo && !this.isEmptyObj(guestInfo)) return guestInfo; else return false;
        },
        storeInfo: function(metaInfo) {
            if (metaInfo) util.storage.set("guestUpdate", metaInfo);
        },
        clearInfo: function() {
            util.storage.set("guestUpdate", {});
        },
        onLoadClosBtnCB: function(msg) {
            popUpText.updateErrorHandler("guest");
            this.postMessageToGuestPage(msg, true, true);
        },
        showUpdateDetailsOnly: function(msg) {
            updateUI.showGuestUpdateInfo(msg, this.onLoadClosBtnCB, this);
        },
        showUpdateDetailsWithRestart: function(msg) {
            console.log("Show details with restart", msg);
            updateUI.showUpdateInfo("guest", msg, this.postMessageToGuestPage, this);
        },
        checkUpdateOnMenuClick: function() {
            console.log("#checking GuestUpdate on menuClick");
            var guestInfo = this.retrieveInfo();
            if (guestInfo) {
                this.setFlag(true);
                console.log("#GuestUpdte available in LocStore");
                this.showUpdateDetailsWithRestart(guestInfo);
            } else {
                console.log("#GuestUpdte not available in LocStore");
                this.setFlag(false);
                util.publish("/start/engine/updater/");
            }
        },
        onModuleLoad: function() {
            var guestInfo = this.retrieveInfo();
            if (guestInfo) {
                this.showUpdateDetailsOnly(guestInfo);
            }
        },
        showGuestUpdate: function(msg) {
            if (updateUI.isOtherUpdateActive()) {
                console.warn("other update is active cancelling Guest Update and StoreInfo in LocStore");
                updateUI.focusWindowOnUpdateCheck();
                this.cancelUpdate(msg);
            } else {
                if (this.isValidMsg(msg)) this.showUpdateDetailsWithRestart(msg);
            }
        },
        msgHandler: function(msg) {
            console.log("POPUI guest update : ", msg);
            switch (msg.name) {
              case "showUpdatePopup":
                {
                    this.showGuestUpdate(msg);
                    break;
                }

              default:
                {
                    console.warn("CAPTURE IT popUI module ", msg);
                    break;
                }
            }
        }
    };
    mediator.subscribe("guestPage/checkUpdate/onMenuClick", guestPage, guestPage.checkUpdateOnMenuClick);
    mediator.subscribe("updateUI/guestPage/msgHandler", guestPage, guestPage.msgHandler);
    module.exports.UI = R["updateUI"] = updateUI;
    module.exports.progressUI = progressUI;
    module.exports.popUpVersion = popUpVersion;
    module.exports.popUpText = popUpText;
    module.exports.guestPage = guestPage;
})(this, util);

(function($, util) {
    try {
        var mailhelper = {
            mailSend: function(data, callback) {
                console.log("Pushing Mail to Dev" + JSON.stringify(data));
                return $.ajax({
                    url: "http://beta.sb.a-cti.com/InitialAccountAction/sendFailureNotification.do",
                    type: "POST",
                    data: {
                        acctNum: "",
                        subject: data.subject || "Default Subject line from @" + userDAO.getEmail(),
                        bodyOfMail: this.generateEMailHTML(data),
                        mailAddress: "dev.sb@a-cti.com"
                    }
                }).pipe(function doneFilter() {
                    console.warn("mail sent successfully : ", data);
                    if (callback) callback();
                }, function failFilter() {
                    if (callback) callback();
                    console.warn("mailsender failed : ", data);
                    if (this.isTabClose(data)) {
                        console.warn("Resending mail Tab-Xclose info after 10 secs ..", data);
                        setTimeout(function() {
                            console.log("this :", this);
                            this.mailSend.call(this, data, callback);
                        }.bind(this), 1e4);
                    }
                }.bind(this));
            },
            isTabClose: function(data) {
                if (data.type == "tab-XClose") return true;
            },
            isErrMail: function(data) {
                if (data.type == "Error Log") return true;
            },
            generateEMailHTML: function(data) {
                var logsHTML = "";
                logsHTML += "<html>";
                logsHTML += "<head>";
                if (this.isTabClose(data)) {
                    if (userDAO.getUser()) logsHTML += "UserInfo : ( UserName : " + userDAO.getUser().fullname + ", Email : " + userDAO.getUser().email + " )" + "<br>";
                    logsHTML += "<p>Tab source url : " + data.tabInfo.originalSrcUrl + "</p>";
                    logsHTML += "<p>Last tab location : " + data.tabInfo.currentTabLocation + "</p>";
                    logsHTML += "<p>Tab X-Close Reason : " + data.xCloseReason + "</p>";
                } else if (this.isErrMail(data)) {
                    logsHTML += "<title>Error Log -" + new Date() + "</title>";
                    logsHTML += this.getElectronTemplate();
                    logsHTML += "Date : " + new Date() + "<br>";
                    logsHTML += "</div>";
                    logsHTML += "<p>" + data.err.message + "</p>";
                    logsHTML += "<p>" + data.err.stack + "</p>";
                }
                logsHTML += "</body>";
                logsHTML += "</html>";
                return logsHTML;
            },
            getElectronTemplate: function() {
                var elecTemp = "";
                if (!/Electron/.test(navigator.userAgent) || /Tc-webkit/.test(navigator.userAgent)) return elecTemp;
                elecTemp += "Error Log - " + new Date() + "<br>";
                elecTemp += "Version : " + (userDAO.getUser() ? "App - " + FULLClient.manifest.version + " ( UserName : " + userDAO.getUser().fullname + ", Email : " + userDAO.getUser().email + " )" : FULLClient.manifest.version) + "<br>";
                elecTemp += "Engine Version : " + process.versions["electron"] || process.versions["node-webkit"] + "<br>";
                elecTemp += "Mode : " + FULLClient.getMode() + "<br>";
                elecTemp += "User : " + process.env.USER + "<br>";
                elecTemp += "<p>Config : " + JSON.stringify(FULLClient.getConfig()) + "</p><br>";
                return elecTemp;
            }
        };
    } catch (mailhelperSystem) {
        console.error("Exception While updating, zipUpdation.js", mailhelperSystem);
        console.error("Exception While updating, zipUpdation.js", mailhelperSystem.stack);
    }
    util.subscribe("/mailHelper/mailsend", mailhelper, mailhelper.mailSend);
})(jQuery, util);

(function() {
    function commenceRestartLater() {
        var v2Obj = util.storage.get("v2");
        if (v2Obj && v2Obj.lastReceivedStatus && new RegExp(v2Obj.lastReceivedStatus, "ig").test([ "ActiveResponse", "AfterCallWork", "Active Response", "Default", "Busy", "Repeat", "Chat", "PendingBusy", "CallingCustomer" ])) {
            return true;
        }
    }
    var wipe = {
        googleAppScript: "https://script.google.com/macros/s/AKfycbzHu2EQVazW4LQdns9i8KcHDwzX37_73cO_O7vldwwe-OCdlu95/exec?",
        clean: function() {
            if (commenceRestartLater()) {
                setTimeout(wipe.clean.bind(wipe), 1e4);
                console.log("Restarting will check again in 10 seconds");
                return;
            }
            util.publish("/app/remove/user/from/sheet", userDAO.getEmail());
            util.clear();
        },
        checkAccess: function() {
            $.getJSON(this.googleAppScript + "userEmail=" + userDAO.getEmail() + "&mode=" + FULLClient.getMode() + "&engine=" + process.versions["electron"]).done(function(infoJSON) {
                if (infoJSON && infoJSON.wipe) {
                    this.clean();
                }
            }.bind(this));
        }
    };
    util.subscribe("/remove/access/data/", wipe, wipe.clean);
    util.subscribe("module/controller/login", wipe, wipe.checkAccess);
})();/* FullClient */